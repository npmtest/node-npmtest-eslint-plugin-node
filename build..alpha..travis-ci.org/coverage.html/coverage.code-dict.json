{"/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/test.js":"/* istanbul instrument in package npmtest_eslint_plugin_node */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/lib.npmtest_eslint_plugin_node.js":"/* istanbul instrument in package npmtest_eslint_plugin_node */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_eslint_plugin_node = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_eslint_plugin_node = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-eslint-plugin-node && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_eslint_plugin_node */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_eslint_plugin_node\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_eslint_plugin_node.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_eslint_plugin_node.rollup.js'] =\n            local.assetsDict['/assets.npmtest_eslint_plugin_node.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_eslint_plugin_node.__dirname +\n                    '/lib.npmtest_eslint_plugin_node.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/index.js":"/**\n * @author Toru Nagashima\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\nmodule.exports = {\n    rules: {\n        \"exports-style\": require(\"./lib/rules/exports-style\"),\n        \"no-deprecated-api\": require(\"./lib/rules/no-deprecated-api\"),\n        \"no-hide-core-modules\": require(\"./lib/rules/no-hide-core-modules\"),\n        \"no-missing-import\": require(\"./lib/rules/no-missing-import\"),\n        \"no-missing-require\": require(\"./lib/rules/no-missing-require\"),\n        \"no-unpublished-bin\": require(\"./lib/rules/no-unpublished-bin\"),\n        \"no-unpublished-import\": require(\"./lib/rules/no-unpublished-import\"),\n        \"no-unpublished-require\": require(\"./lib/rules/no-unpublished-require\"),\n        \"no-unsupported-features\": require(\"./lib/rules/no-unsupported-features\"),\n        \"process-exit-as-throw\": require(\"./lib/rules/process-exit-as-throw\"),\n        \"shebang\": require(\"./lib/rules/shebang\"),\n    },\n    rulesConfig: {\n        \"exports-style\": \"off\",\n        \"no-deprecated-api\": \"off\",\n        \"no-hide-core-modules\": \"off\",\n        \"no-missing-import\": \"off\",\n        \"no-missing-require\": \"off\",\n        \"no-unpublished-bin\": \"off\",\n        \"no-unpublished-import\": \"off\",\n        \"no-unpublished-require\": \"off\",\n        \"no-unsupported-features\": \"off\",\n        \"process-exit-as-throw\": \"off\",\n        \"shebang\": \"off\",\n    },\n    configs: {recommended: require(\"./conf/recommended.json\")},\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/rules/exports-style.js":"/**\n * @author Toru Nagashima\n * @copyright 2016 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/*istanbul ignore next */\n/**\n * This function is copied from https://github.com/eslint/eslint/blob/2355f8d0de1d6732605420d15ddd4f1eee3c37b6/lib/ast-utils.js#L648-L684\n *\n * @param {ASTNode} node - The node to get.\n * @returns {string|null} The property name if static. Otherwise, null.\n * @private\n */\nfunction getStaticPropertyName(node) {\n    let prop = null\n\n    switch (node && node.type) {\n        case \"Property\":\n        case \"MethodDefinition\":\n            prop = node.key\n            break\n\n        case \"MemberExpression\":\n            prop = node.property\n            break\n\n        // no default\n    }\n\n    switch (prop && prop.type) {\n        case \"Literal\":\n            return String(prop.value)\n\n        case \"TemplateLiteral\":\n            if (prop.expressions.length === 0 && prop.quasis.length === 1) {\n                return prop.quasis[0].value.cooked\n            }\n            break\n\n        case \"Identifier\":\n            if (!node.computed) {\n                return prop.name\n            }\n            break\n\n        // no default\n    }\n\n    return null\n}\n\n/**\n * Checks whether the given node is assignee or not.\n *\n * @param {ASTNode} node - The node to check.\n * @returns {boolean} `true` if the node is assignee.\n */\nfunction isAssignee(node) {\n    return (\n        node.parent.type === \"AssignmentExpression\" &&\n        node.parent.left === node\n    )\n}\n\n/**\n * Gets the top assignment expression node if the given node is an assignee.\n *\n * This is used to distinguish 2 assignees belong to the same assignment.\n * If the node is not an assignee, this returns null.\n *\n * @param {ASTNode} leafNode - The node to get.\n * @returns {ASTNode|null} The top assignment expression node, or null.\n */\nfunction getTopAssignment(leafNode) {\n    let node = leafNode\n\n    // Skip MemberExpressions.\n    while (node.parent.type === \"MemberExpression\" && node.parent.object === node) {\n        node = node.parent\n    }\n\n    // Check assignments.\n    if (!isAssignee(node)) {\n        return null\n    }\n\n    // Find the top.\n    while (node.parent.type === \"AssignmentExpression\") {\n        node = node.parent\n    }\n\n    return node\n}\n\n/**\n * Gets top assignment nodes of the given node list.\n *\n * @param {ASTNode[]} nodes - The node list to get.\n * @returns {ASTNode[]} Gotten top assignment nodes.\n */\nfunction createAssignmentList(nodes) {\n    return nodes.map(getTopAssignment).filter(Boolean)\n}\n\n/**\n * Gets the reference of `module.exports` from the given scope.\n *\n * @param {escope.Scope} scope - The scope to get.\n * @returns {ASTNode[]} Gotten MemberExpression node list.\n */\nfunction getModuleExportsNodes(scope) {\n    const variable = scope.set.get(\"module\")\n    if (variable == null) {\n        return []\n    }\n    return variable.references\n        .map(reference => reference.identifier.parent)\n        .filter(node => (\n            node.type === \"MemberExpression\" &&\n            getStaticPropertyName(node) === \"exports\"\n        ))\n}\n\n/**\n * Gets the reference of `exports` from the given scope.\n *\n * @param {escope.Scope} scope - The scope to get.\n * @returns {ASTNode[]} Gotten Identifier node list.\n */\nfunction getExportsNodes(scope) {\n    const variable = scope.set.get(\"exports\")\n    if (variable == null) {\n        return []\n    }\n    return variable.references.map(reference => reference.identifier)\n}\n\n/**\n * The definition of this rule.\n *\n * @param {RuleContext} context - The rule context to check.\n * @returns {object} The definition of this rule.\n */\nfunction create(context) {\n    const mode = context.options[0] || \"module.exports\"\n    const batchAssignAllowed = Boolean(\n        context.options[1] != null &&\n        context.options[1].allowBatchAssign\n    )\n    const sourceCode = context.getSourceCode()\n\n    /**\n     * Gets the location info of reports.\n     *\n     * exports = foo\n     * ^^^^^^^^^\n     *\n     * module.exports = foo\n     * ^^^^^^^^^^^^^^^^\n     *\n     * @param {ASTNode} node - The node of `exports`/`module.exports`.\n     * @returns {Location} The location info of reports.\n     */\n    function getLocation(node) {\n        const token = sourceCode.getTokenAfter(node)\n        return {\n            start: node.loc.start,\n            end: token.loc.end,\n        }\n    }\n\n    /**\n     * Enforces `module.exports`.\n     * This warns references of `exports`.\n     *\n     * @returns {void}\n     */\n    function enforceModuleExports() {\n        const globalScope = context.getScope()\n        const exportsNodes = getExportsNodes(globalScope)\n        const assignList = batchAssignAllowed\n            ? createAssignmentList(getModuleExportsNodes(globalScope))\n            : []\n\n        for (const node of exportsNodes) {\n            // Skip if it's a batch assignment.\n            if (assignList.length > 0 &&\n                assignList.indexOf(getTopAssignment(node)) !== -1\n            ) {\n                continue\n            }\n\n            // Report.\n            context.report({\n                node,\n                loc: getLocation(node),\n                message:\n                    \"Unexpected access to 'exports'. \" +\n                    \"Use 'module.exports' instead.\",\n            })\n        }\n    }\n\n    /**\n     * Enforces `exports`.\n     * This warns references of `module.exports`.\n     *\n     * @returns {void}\n     */\n    function enforceExports() {\n        const globalScope = context.getScope()\n        const exportsNodes = getExportsNodes(globalScope)\n        const moduleExportsNodes = getModuleExportsNodes(globalScope)\n        const assignList = batchAssignAllowed\n            ? createAssignmentList(exportsNodes)\n            : []\n        const batchAssignList = []\n\n        for (const node of moduleExportsNodes) {\n            // Skip if it's a batch assignment.\n            if (assignList.length > 0) {\n                const found = assignList.indexOf(getTopAssignment(node))\n                if (found !== -1) {\n                    batchAssignList.push(assignList[found])\n                    assignList.splice(found, 1)\n                    continue\n                }\n            }\n\n            // Report.\n            context.report({\n                node,\n                loc: getLocation(node),\n                message:\n                    \"Unexpected access to 'module.exports'. \" +\n                    \"Use 'exports' instead.\",\n            })\n        }\n\n        // Disallow direct assignment to `exports`.\n        for (const node of exportsNodes) {\n            // Skip if it's not assignee.\n            if (!isAssignee(node)) {\n                continue\n            }\n\n            // Check if it's a batch assignment.\n            if (batchAssignList.indexOf(getTopAssignment(node)) !== -1) {\n                continue\n            }\n\n            // Report.\n            context.report({\n                node,\n                loc: getLocation(node),\n                message:\n                    \"Unexpected assignment to 'exports'. \" +\n                    \"Don't modify 'exports' itself.\",\n            })\n        }\n    }\n\n    return {\n        \"Program:exit\"() {\n            switch (mode) {\n                case \"module.exports\":\n                    enforceModuleExports()\n                    break\n                case \"exports\":\n                    enforceExports()\n                    break\n\n                // no default\n            }\n        },\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create,\n    meta: {\n        docs: {\n            description: \"enforce either `module.exports` or `exports`\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n        },\n        fixable: false,\n        schema: [\n            { //\n                enum: [\"module.exports\", \"exports\"],\n            },\n            {\n                type: \"object\",\n                properties: {allowBatchAssign: {type: \"boolean\"}},\n                additionalProperties: false,\n            },\n        ],\n    },\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/rules/no-deprecated-api.js":"/**\n * @fileoverview Rule to disallow deprecated API.\n * @author Toru Nagashima\n * @copyright 2016 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assign = require(\"object-assign\")\nconst deprecatedApis = require(\"../util/deprecated-apis\")\nconst getValueIfString = require(\"../util/get-value-if-string\")\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:.+?Statement|.+?Declaration|(?:Array|ArrowFunction|Assignment|Call|Class|Function|Member|New|Object)Expression|AssignmentPattern|Program|VariableDeclarator)$/\nconst MODULE_ITEMS = getDeprecatedItems(deprecatedApis.modules, [], [])\nconst GLOBAL_ITEMS = getDeprecatedItems(deprecatedApis.globals, [], [])\n\n/**\n * Gets the array of deprecated items.\n *\n * It's the paths which are separated by dots.\n * E.g. `buffer.Buffer`, `events.EventEmitter.listenerCount`\n *\n * @param {object} definition - The definition of deprecated APIs.\n * @param {string[]} result - The array of the result.\n * @param {string[]} stack - The array to manage the stack of paths.\n * @returns {string[]} `result`.\n */\nfunction getDeprecatedItems(definition, result, stack) {\n    for (const key of Object.keys(definition)) {\n        const item = definition[key]\n\n        if (key === \"$call\") {\n            result.push(`${stack.join(\".\")}()`)\n        }\n        else if (key === \"$constructor\") {\n            result.push(`new ${stack.join(\".\")}()`)\n        }\n        else {\n            stack.push(key)\n\n            if (item.$deprecated) {\n                result.push(stack.join(\".\"))\n            }\n            else {\n                getDeprecatedItems(item, result, stack)\n            }\n\n            stack.pop()\n        }\n    }\n\n    return result\n}\n\n/**\n * Converts from a version number to a version text to display.\n *\n * @param {number} value - A version number to convert.\n * @returns {string} Covnerted text.\n */\nfunction toVersionText(value) {\n    if (value <= 0.12) {\n        return value.toFixed(2)\n    }\n    if (value < 1) {\n        return value.toFixed(1)\n    }\n    return String(value)\n}\n\n/**\n * Makes a replacement message.\n *\n * @param {string|null} replacedBy - The text of substitute way.\n * @returns {string} Replacement message.\n */\nfunction toReplaceMessage(replacedBy) {\n    return replacedBy ? ` Use ${replacedBy} instead.` : \"\"\n}\n\n/**\n * Gets the property name from a MemberExpression node or a Property node.\n *\n * @param {ASTNode} node - A node to get.\n * @returns {string|null} The property name of the node.\n */\nfunction getPropertyName(node) {\n    switch (node.type) {\n        case \"MemberExpression\":\n            if (node.computed) {\n                return getValueIfString(node.property)\n            }\n            return node.property.name\n\n        case \"Property\":\n            if (node.computed) {\n                return getValueIfString(node.key)\n            }\n            if (node.key.type === \"Literal\") {\n                return String(node.key.value)\n            }\n            return node.key.name\n\n        // no default\n    }\n\n    /* istanbul ignore next: unreachable */\n    return null\n}\n\n/**\n * Checks a given node is a ImportDeclaration node.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a ImportDeclaration node.\n */\nfunction isImportDeclaration(node) {\n    return node.type === \"ImportDeclaration\"\n}\n\n/**\n * Finds the variable object of a given Identifier node.\n *\n * @param {ASTNode} node - An Identifier node to find.\n * @param {escope.Scope} initialScope - A scope to start searching.\n * @returns {escope.Variable} Found variable object.\n */\nfunction findVariable(node, initialScope) {\n    const location = node.range[0]\n    let variable = null\n\n    // Dive into the scope that the node exists.\n    for (const childScope of initialScope.childScopes) {\n        const range = childScope.block.range\n\n        if (range[0] <= location && location < range[1]) {\n            variable = findVariable(node, childScope)\n            if (variable != null) {\n                return variable\n            }\n        }\n    }\n\n    // Find the variable of that name in this scope or ancestor scopes.\n    let scope = initialScope\n    while (scope != null) {\n        variable = scope.set.get(node.name)\n        if (variable != null) {\n            return variable\n        }\n\n        scope = scope.upper\n    }\n\n    return null\n}\n\n/**\n * Gets the top member expression node.\n *\n * @param {ASTNode} identifier - The node to get.\n * @returns {ASTNode} The top member expression node.\n */\nfunction getTopMemberExpression(identifier) {\n    if (identifier.type !== \"Identifier\" && identifier.type !== \"Literal\") {\n        return identifier\n    }\n\n    let node = identifier\n    while (node.parent.type === \"MemberExpression\") {\n        node = node.parent\n    }\n\n    return node\n}\n\n/**\n * The definition of this rule.\n *\n * @param {RuleContext} context - The rule context to check.\n * @returns {object} The definition of this rule.\n */\nfunction create(context) {\n    const options = context.options[0] || {}\n    const ignoredModuleItems = options.ignoreModuleItems || []\n    const ignoredGlobalItems = options.ignoreGlobalItems || []\n    let globalScope = null\n\n    /**\n     * Reports a use of a deprecated API.\n     *\n     * @param {ASTNode} node - A node to report.\n     * @param {string} name - The name of a deprecated API.\n     * @param {{since: number, replacedBy: string}} info - Information of the API.\n     * @returns {void}\n     */\n    function report(node, name, info) {\n        context.report({\n            node,\n            loc: getTopMemberExpression(node).loc,\n            message: \"{{name}} was deprecated since v{{version}}.{{replace}}\",\n            data: {\n                name,\n                version: toVersionText(info.since),\n                replace: toReplaceMessage(info.replacedBy),\n            },\n        })\n    }\n\n    /**\n     * Reports a use of a deprecated module.\n     *\n     * @param {ASTNode} node - A node to report.\n     * @param {string} name - The name of a deprecated module.\n     * @param {{since: number, replacedBy: string, global: boolean}} info - Information of the module.\n     * @returns {void}\n     */\n    function reportModule(node, name, info) {\n        if (ignoredModuleItems.indexOf(name) === -1) {\n            report(node, `'${name}' module`, info)\n        }\n    }\n\n    /**\n     * Reports a use of a deprecated property.\n     *\n     * @param {ASTNode} node - A node to report.\n     * @param {string[]} path - The path to a deprecated property.\n     * @param {{since: number, replacedBy: string, global: boolean}} info - Information of the property.\n     * @returns {void}\n     */\n    function reportCall(node, path, info) {\n        const ignored = info.global ? ignoredGlobalItems : ignoredModuleItems\n        const name = `${path.join(\".\")}()`\n\n        if (ignored.indexOf(name) === -1) {\n            report(node, `'${name}'`, info)\n        }\n    }\n\n    /**\n     * Reports a use of a deprecated property.\n     *\n     * @param {ASTNode} node - A node to report.\n     * @param {string[]} path - The path to a deprecated property.\n     * @param {{since: number, replacedBy: string, global: boolean}} info - Information of the property.\n     * @returns {void}\n     */\n    function reportConstructor(node, path, info) {\n        const ignored = info.global ? ignoredGlobalItems : ignoredModuleItems\n        const name = `new ${path.join(\".\")}()`\n\n        if (ignored.indexOf(name) === -1) {\n            report(node, `'${name}'`, info)\n        }\n    }\n\n    /**\n     * Reports a use of a deprecated property.\n     *\n     * @param {ASTNode} node - A node to report.\n     * @param {string[]} path - The path to a deprecated property.\n     * @param {string} key - The name of the property.\n     * @param {{since: number, replacedBy: string, global: boolean}} info - Information of the property.\n     * @returns {void}\n     */\n    function reportProperty(node, path, key, info) {\n        const ignored = info.global ? ignoredGlobalItems : ignoredModuleItems\n        const name = `${path.join(\".\")}.${key}`\n\n        if (ignored.indexOf(name) === -1) {\n            report(node, `'${name}'`, info)\n        }\n    }\n\n    /**\n     * Checks violations in destructuring assignments.\n     *\n     * @param {ASTNode} node - A pattern node to check.\n     * @param {string[]} path - The path to a deprecated property.\n     * @param {object} infoMap - A map of properties' information.\n     * @returns {void}\n     */\n    function checkDestructuring(node, path, infoMap) {\n        switch (node.type) {\n            case \"AssignmentPattern\":\n                checkDestructuring(node.left, path, infoMap)\n                break\n\n            case \"Identifier\": {\n                const variable = findVariable(node, globalScope)\n                if (variable != null) {\n                    checkVariable(variable, path, infoMap)\n                }\n                break\n            }\n            case \"ObjectPattern\":\n                for (const property of node.properties) {\n                    const key = getPropertyName(property)\n                    if (key != null && hasOwnProperty.call(infoMap, key)) {\n                        const keyInfo = infoMap[key]\n                        if (keyInfo.$deprecated) {\n                            reportProperty(property.key, path, key, keyInfo)\n                        }\n                        else {\n                            path.push(key)\n                            checkDestructuring(property.value, path, keyInfo)\n                            path.pop()\n                        }\n                    }\n                }\n                break\n\n            // no default\n        }\n    }\n\n    /**\n     * Checks violations in properties.\n     *\n     * @param {ASTNode} root - A node to check.\n     * @param {string[]} path - The path to a deprecated property.\n     * @param {object} infoMap - A map of properties' information.\n     * @returns {void}\n     */\n    function checkProperties(root, path, infoMap) { //eslint-disable-line complexity\n        let node = root\n        while (!SENTINEL_TYPE.test(node.parent.type)) {\n            node = node.parent\n        }\n\n        const parent = node.parent\n        switch (parent.type) {\n            case \"CallExpression\":\n                if (parent.callee === node && infoMap.$call != null) {\n                    reportCall(parent, path, infoMap.$call)\n                }\n                break\n\n            case \"NewExpression\":\n                if (parent.callee === node && infoMap.$constructor != null) {\n                    reportConstructor(parent, path, infoMap.$constructor)\n                }\n                break\n\n            case \"MemberExpression\":\n                if (parent.object === node) {\n                    const key = getPropertyName(parent)\n                    if (key != null && hasOwnProperty.call(infoMap, key)) {\n                        const keyInfo = infoMap[key]\n                        if (keyInfo.$deprecated) {\n                            reportProperty(parent.property, path, key, keyInfo)\n                        }\n                        else {\n                            path.push(key)\n                            checkProperties(parent, path, keyInfo)\n                            path.pop()\n                        }\n                    }\n                }\n                break\n\n            case \"AssignmentExpression\":\n                if (parent.right === node) {\n                    checkDestructuring(parent.left, path, infoMap)\n                    checkProperties(parent, path, infoMap)\n                }\n                break\n\n            case \"AssignmentPattern\":\n                if (parent.right === node) {\n                    checkDestructuring(parent.left, path, infoMap)\n                }\n                break\n\n            case \"VariableDeclarator\":\n                if (parent.init === node) {\n                    checkDestructuring(parent.id, path, infoMap)\n                }\n                break\n\n            // no default\n        }\n    }\n\n    /**\n     * Checks violations in the references of a given variable.\n     *\n     * @param {escope.Variable} variable - A variable to check.\n     * @param {string[]} path - The path to a deprecated property.\n     * @param {object} infoMap - A map of properties' information.\n     * @returns {void}\n     */\n    function checkVariable(variable, path, infoMap) {\n        for (const reference of variable.references.filter(r => r.isRead())) {\n            checkProperties(reference.identifier, path, infoMap)\n        }\n    }\n\n    /**\n     * Checks violations in a ModuleSpecifier node.\n     *\n     * @param {ASTNode} node - A ModuleSpecifier node to check.\n     * @param {string[]} path - The path to a deprecated property.\n     * @param {object} infoMap - A map of properties' information.\n     * @returns {void}\n     */\n    function checkImportSpecifier(node, path, infoMap) {\n        switch (node.type) {\n            case \"ImportSpecifier\": {\n                const key = node.imported.name\n                if (hasOwnProperty.call(infoMap, key)) {\n                    const keyInfo = infoMap[key]\n                    if (keyInfo.$deprecated) {\n                        reportProperty(node.imported, path, key, keyInfo)\n                    }\n                    else {\n                        path.push(key)\n                        checkVariable(\n                            findVariable(node.local, globalScope),\n                            path,\n                            keyInfo\n                        )\n                        path.pop()\n                    }\n                }\n                break\n            }\n            case \"ImportDefaultSpecifier\":\n                checkVariable(\n                    findVariable(node.local, globalScope),\n                    path,\n                    infoMap\n                )\n                break\n\n            case \"ImportNamespaceSpecifier\":\n                checkVariable(\n                    findVariable(node.local, globalScope),\n                    path,\n                    assign({}, infoMap, {default: infoMap})\n                )\n                break\n\n            // no default\n        }\n    }\n\n    /**\n     * Checks violations for CommonJS modules.\n     * @returns {void}\n     */\n    function checkCommonJsModules() {\n        const infoMap = deprecatedApis.modules\n        const variable = globalScope.set.get(\"require\")\n\n        if (variable == null || variable.defs.length !== 0) {\n            return\n        }\n\n        for (const reference of variable.references.filter(r => r.isRead())) {\n            const id = reference.identifier\n            const node = id.parent\n\n            if (node.type === \"CallExpression\" && node.callee === id) {\n                const key = getValueIfString(node.arguments[0])\n                if (key != null && hasOwnProperty.call(infoMap, key)) {\n                    const moduleInfo = infoMap[key]\n                    if (moduleInfo.$deprecated) {\n                        reportModule(node, key, moduleInfo)\n                    }\n                    else {\n                        checkProperties(node, [key], moduleInfo)\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Checks violations for ES2015 modules.\n     * @param {ASTNode} programNode - A program node to check.\n     * @returns {void}\n     */\n    function checkES2015Modules(programNode) {\n        const infoMap = deprecatedApis.modules\n\n        for (const node of programNode.body.filter(isImportDeclaration)) {\n            const key = node.source.value\n            if (hasOwnProperty.call(infoMap, key)) {\n                const moduleInfo = infoMap[key]\n                if (moduleInfo.$deprecated) {\n                    reportModule(node, key, moduleInfo)\n                }\n                else {\n                    for (const specifier of node.specifiers) {\n                        checkImportSpecifier(specifier, [key], moduleInfo)\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Checks violations for global variables.\n     * @returns {void}\n     */\n    function checkGlobals() {\n        const infoMap = deprecatedApis.globals\n\n        for (const key of Object.keys(infoMap)) {\n            const keyInfo = infoMap[key]\n            const variable = globalScope.set.get(key)\n\n            if (variable != null && variable.defs.length === 0) {\n                checkVariable(variable, [key], keyInfo)\n            }\n        }\n    }\n\n    return {\n        \"Program:exit\"(node) {\n            globalScope = context.getScope()\n\n            checkCommonJsModules()\n            checkES2015Modules(node)\n            checkGlobals()\n        },\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create,\n    meta: {\n        docs: {\n            description: \"disallow deprecated APIs\",\n            category: \"Best Practices\",\n            recommended: false,\n        },\n        fixable: false,\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreModuleItems: {\n                        type: \"array\",\n                        items: {enum: MODULE_ITEMS},\n                        additionalItems: false,\n                        uniqueItems: true,\n                    },\n                    ignoreGlobalItems: {\n                        type: \"array\",\n                        items: {enum: GLOBAL_ITEMS},\n                        additionalItems: false,\n                        uniqueItems: true,\n                    },\n\n                    // Deprecated since v4.2.0\n                    ignoreIndirectDependencies: {type: \"boolean\"},\n                },\n                additionalProperties: false,\n            },\n        ],\n    },\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/util/deprecated-apis.js":"/**\n * @author Toru Nagashima\n * @copyright 2016 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    modules: {\n        buffer: {\n            Buffer: {\n                $constructor: {\n                    $deprecated: true,\n                    since: 6,\n                    replacedBy: \"'buffer.Buffer.alloc()' or 'buffer.Buffer.from()' (use 'https://www.npmjs.com/package/safe-buffer' for '<4.5.0')\",\n                },\n                $call: {\n                    $deprecated: true,\n                    since: 6,\n                    replacedBy: \"'buffer.Buffer.alloc()' or 'buffer.Buffer.from()' (use 'https://www.npmjs.com/package/safe-buffer' for '<4.5.0')\",\n                },\n            },\n            SlowBuffer: {\n                $deprecated: true,\n                since: 6,\n                replacedBy: \"'buffer.Buffer.allocUnsafeSlow()'\",\n            },\n        },\n        crypto: {\n            createCredentials: {\n                $deprecated: true,\n                since: 0.12,\n                replacedBy: \"'tls.createSecureContext()'\",\n            },\n        },\n        domain: {\n            $deprecated: true,\n            since: 4,\n            replacedBy: null,\n        },\n        events: {\n            EventEmitter: {\n                listenerCount: {\n                    $deprecated: true,\n                    since: 4,\n                    replacedBy: \"'events.EventEmitter#listenerCount()'\",\n                },\n            },\n            listenerCount: {\n                $deprecated: true,\n                since: 4,\n                replacedBy: \"'events.EventEmitter#listenerCount()'\",\n            },\n        },\n        fs: {\n            exists: {\n                $deprecated: true,\n                since: 4,\n                replacedBy: \"'fs.stat()' or 'fs.access()'\",\n            },\n        },\n        http: {\n            createClient: {\n                $deprecated: true,\n                since: 0.10,\n                replacedBy: \"'http.request()'\",\n            },\n        },\n        module: {\n            Module: {\n                requireRepl: {\n                    $deprecated: true,\n                    since: 6,\n                    replacedBy: \"'require(\\\"repl\\\")'\",\n                },\n            },\n            requireRepl: {\n                $deprecated: true,\n                since: 6,\n                replacedBy: \"'require(\\\"repl\\\")'\",\n            },\n        },\n        os: {\n            tmpDir: {\n                $deprecated: true,\n                since: 7,\n                replacedBy: \"'os.tmpdir()'\",\n            },\n        },\n        punycode: {\n            $deprecated: true,\n            since: 7,\n            replacedBy: \"'https://www.npmjs.com/package/punycode'\",\n        },\n        readline: {\n            codePointAt: {\n                $deprecated: true,\n                since: 4,\n                replacedBy: null,\n            },\n            getStringWidth: {\n                $deprecated: true,\n                since: 6,\n                replacedBy: null,\n            },\n            isFullWidthCodePoint: {\n                $deprecated: true,\n                since: 6,\n                replacedBy: null,\n            },\n            stripVTControlCharacters: {\n                $deprecated: true,\n                since: 6,\n                replacedBy: null,\n            },\n        },\n        tls: {\n            CleartextStream: {\n                $deprecated: true,\n                since: 0.10,\n                replacedBy: null,\n            },\n            CryptoStream: {\n                $deprecated: true,\n                since: 0.12,\n                replacedBy: \"'tls.TLSSocket'\",\n            },\n            SecurePair: {\n                $deprecated: true,\n                since: 6,\n                replacedBy: \"'tls.TLSSocket'\",\n            },\n            createSecurePair: {\n                $deprecated: true,\n                since: 6,\n                replacedBy: \"'tls.TLSSocket'\",\n            },\n        },\n        tty: {\n            setRawMode: {\n                $deprecated: true,\n                since: 0.10,\n                replacedBy: \"'tty.ReadStream#setRawMode()' (e.g. 'process.stdin.setRawMode()')\",\n            },\n        },\n        util: {\n            debug: {\n                $deprecated: true,\n                since: 0.12,\n                replacedBy: \"'console.error()'\",\n            },\n            error: {\n                $deprecated: true,\n                since: 0.12,\n                replacedBy: \"'console.error()'\",\n            },\n            isArray: {\n                $deprecated: true,\n                since: 4,\n                replacedBy: \"'Array.isArray()'\",\n            },\n            isBoolean: {\n                $deprecated: true,\n                since: 4,\n                replacedBy: null,\n            },\n            isBuffer: {\n                $deprecated: true,\n                since: 4,\n                replacedBy: \"'Buffer.isBuffer()'\",\n            },\n            isDate: {\n                $deprecated: true,\n                since: 4,\n                replacedBy: null,\n            },\n            isError: {\n                $deprecated: true,\n                since: 4,\n                replacedBy: null,\n            },\n            isFunction: {\n                $deprecated: true,\n                since: 4,\n                replacedBy: null,\n            },\n            isNull: {\n                $deprecated: true,\n                since: 4,\n                replacedBy: null,\n            },\n            isNullOrUndefined: {\n                $deprecated: true,\n                since: 4,\n                replacedBy: null,\n            },\n            isNumber: {\n                $deprecated: true,\n                since: 4,\n                replacedBy: null,\n            },\n            isObject: {\n                $deprecated: true,\n                since: 4,\n                replacedBy: null,\n            },\n            isPrimitive: {\n                $deprecated: true,\n                since: 4,\n                replacedBy: null,\n            },\n            isRegExp: {\n                $deprecated: true,\n                since: 4,\n                replacedBy: null,\n            },\n            isString: {\n                $deprecated: true,\n                since: 4,\n                replacedBy: null,\n            },\n            isSymbol: {\n                $deprecated: true,\n                since: 4,\n                replacedBy: null,\n            },\n            isUndefined: {\n                $deprecated: true,\n                since: 4,\n                replacedBy: null,\n            },\n            log: {\n                $deprecated: true,\n                since: 6,\n                replacedBy: \"a third party module\",\n            },\n            print: {\n                $deprecated: true,\n                since: 0.12,\n                replacedBy: \"'console.log()'\",\n            },\n            pump: {\n                $deprecated: true,\n                since: 0.10,\n                replacedBy: \"'stream.Readable#pipe()'\",\n            },\n            puts: {\n                $deprecated: true,\n                since: 0.12,\n                replacedBy: \"'console.log()'\",\n            },\n            _extend: {\n                $deprecated: true,\n                since: 6,\n                replacedBy: \"'Object.assign()'\",\n            },\n        },\n    },\n    globals: {\n        Buffer: {\n            $constructor: {\n                $deprecated: true,\n                global: true,\n                since: 6,\n                replacedBy: \"'Buffer.alloc()' or 'Buffer.from()' (use 'https://www.npmjs.com/package/safe-buffer' for '<4.5.0')\",\n            },\n            $call: {\n                $deprecated: true,\n                global: true,\n                since: 6,\n                replacedBy: \"'Buffer.alloc()' or 'Buffer.from()' (use 'https://www.npmjs.com/package/safe-buffer' for '<4.5.0')\",\n            },\n        },\n        Intl: {\n            v8BreakIterator: {\n                $deprecated: true,\n                global: true,\n                since: 7,\n                replacedBy: null,\n            },\n        },\n        require: {\n            extensions: {\n                $deprecated: true,\n                global: true,\n                since: 0.12,\n                replacedBy: \"compiling them ahead of time\",\n            },\n        },\n        process: {\n            EventEmitter: {\n                $deprecated: true,\n                global: true,\n                since: 0.6,\n                replacedBy: \"'require(\\\"events\\\")'\",\n            },\n            env: {\n                NODE_REPL_HISTORY_FILE: {\n                    $deprecated: true,\n                    global: true,\n                    since: 4,\n                    replacedBy: \"'NODE_REPL_HISTORY'\",\n                },\n            },\n        },\n    },\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/util/get-value-if-string.js":"/**\n * @author Toru Nagashima\n * @copyright 2016 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Gets the value of a given node if it's a literal or a template literal.\n *\n * @param {ASTNode} node - A node to get.\n * @returns {string|null} The value of the node, or `null`.\n */\nmodule.exports = function getValueIfString(node) {\n    if (!node) {\n        return null\n    }\n\n    switch (node.type) {\n        case \"Literal\":\n            if (typeof node.value === \"string\") {\n                return node.value\n            }\n            break\n\n        case \"TemplateLiteral\":\n            if (node.expressions.length === 0) {\n                return node.quasis[0].value.cooked\n            }\n            break\n\n        // no default\n    }\n\n    return null\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/rules/no-hide-core-modules.js":"/**\n * @author Toru Nagashima\n * @copyright 2016 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n *\n * @deprecated since v4.2.0\n * This rule was based on an invalid assumption.\n * No meaning.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\")\nconst resolve = require(\"resolve\")\nconst getPackageJson = require(\"../util/get-package-json\")\nconst getRequireTargets = require(\"../util/get-require-targets\")\nconst getImportExportTargets = require(\"../util/get-import-export-targets\")\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst CORE_MODULES = new Set([\n    \"assert\", \"buffer\", \"child_process\", \"cluster\", \"console\", \"constants\",\n    \"crypto\", \"dgram\", \"dns\", /* \"domain\", */ \"events\", \"fs\", \"http\", \"https\",\n    \"module\", \"net\", \"os\", \"path\", /* \"punycode\", */ \"querystring\", \"readline\",\n    \"repl\", \"stream\", \"string_decoder\", \"timers\", \"tls\", \"tty\", \"url\", \"util\",\n    \"vm\", \"zlib\",\n])\nconst BACK_SLASH = /\\\\/g\n\n/**\n * Creates AST event handlers for no-hide-core-modules.\n *\n * @param {RuleContext} context - The rule context.\n * @returns {object} AST event handlers.\n */\nfunction create(context) {\n    if (context.getFilename() === \"<input>\") {\n        return {}\n    }\n    const filePath = path.resolve(context.getFilename())\n    const dirPath = path.dirname(filePath)\n    const packageJson = getPackageJson(filePath)\n    const deps = new Set([].concat(\n        Object.keys((packageJson && packageJson.dependencies) || {}),\n        Object.keys((packageJson && packageJson.devDependencies) || {})\n    ))\n    const options = context.options[0] || {}\n    const allow = options.allow || []\n    const ignoreDirectDependencies = Boolean(options.ignoreDirectDependencies)\n    const ignoreIndirectDependencies = Boolean(options.ignoreIndirectDependencies)\n\n    return {\n        \"Program:exit\"(node) {\n            const targets =\n                [].concat(\n                    getRequireTargets(context, true),\n                    getImportExportTargets(context, node, true)\n                )\n                .filter(t => CORE_MODULES.has(t.moduleName))\n\n            for (const target of targets) {\n                const name = target.moduleName\n                const allowed =\n                    allow.indexOf(name) !== -1 ||\n                    (ignoreDirectDependencies && deps.has(name)) ||\n                    (ignoreIndirectDependencies && !deps.has(name))\n\n                if (allowed) {\n                    continue\n                }\n\n                const resolved = resolve.sync(name, {basedir: dirPath})\n                const isCore = resolved === name\n\n                if (isCore) {\n                    continue\n                }\n\n                context.report({\n                    node: target.node,\n                    loc: target.node.loc,\n                    message: \"Unexpected import of third-party module '{{name}}'.\",\n                    data: {\n                        name: path\n                            .relative(dirPath, resolved)\n                            .replace(BACK_SLASH, \"/\"),\n                    },\n                })\n            }\n        },\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create,\n    meta: {\n        docs: {\n            description: \"disallow third-party modules which are hiding core modules\",\n            category: \"Possible Errors\",\n            recommended: false,\n        },\n        deprecated: true,\n        fixable: false,\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: {enum: Array.from(CORE_MODULES)},\n                        additionalItems: false,\n                        uniqueItems: true,\n                    },\n                    ignoreDirectDependencies: {type: \"boolean\"},\n                    ignoreIndirectDependencies: {type: \"boolean\"},\n                },\n                additionalProperties: false,\n            },\n        ],\n    },\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/util/get-package-json.js":"/**\n * @author Toru Nagashima\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\")\nconst path = require(\"path\")\nconst Cache = require(\"./cache\")\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst cache = new Cache()\n\n/**\n * Reads the `package.json` data in a given path.\n *\n * Don't cache the data.\n *\n * @param {string} dir - The path to a directory to read.\n * @returns {object|null} The read `package.json` data, or null.\n */\nfunction readPackageJson(dir) {\n    const filePath = path.join(dir, \"package.json\")\n    try {\n        const text = fs.readFileSync(filePath, \"utf8\")\n        const data = JSON.parse(text)\n\n        if (typeof data === \"object\" && data !== null) {\n            data.filePath = filePath\n            return data\n        }\n    }\n    catch (_err) {\n        // do nothing.\n    }\n\n    return null\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Gets a `package.json` data.\n * The data is cached if found, then it's used after.\n *\n * @param {string} startPath - A file path to lookup.\n * @returns {object|null} A found `package.json` data or `null`.\n *      This object have additional property `filePath`.\n */\nmodule.exports = function getPackageJson(startPath) {\n    const startDir = path.dirname(path.resolve(startPath))\n    let dir = startDir\n    let prevDir = \"\"\n    let data = null\n\n    do {\n        data = cache.get(dir)\n        if (data) {\n            if (dir !== startDir) {\n                cache.put(startDir, data)\n            }\n            return data\n        }\n\n        data = readPackageJson(dir)\n        if (data) {\n            cache.put(dir, data)\n            cache.put(startDir, data)\n            return data\n        }\n\n        // Go to next.\n        prevDir = dir\n        dir = path.resolve(dir, \"..\")\n    }\n    while (dir !== prevDir)\n\n    cache.put(startDir, null)\n    return null\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/util/cache.js":"/**\n * @author Toru Nagashima\n * @copyright 2016 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SKIP_TIME = 5000\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class of cache.\n * The cache will dispose of each value if the value has not been accessed\n * during 5 seconds.\n *\n * @constructor\n */\nconst Cache = module.exports = function Cache() {\n    this.map = Object.create(null)\n}\n\nObject.defineProperties(Cache.prototype, {\n    get: {\n        value: function get(key) {\n            const entry = this.map[key]\n            const now = Date.now()\n\n            if (entry && entry.expire - now > 0) {\n                entry.expire = now + SKIP_TIME\n                return entry.value\n            }\n            return null\n        },\n        configurable: true,\n        writable: true,\n    },\n\n    put: {\n        value: function put(key, value) {\n            const entry = this.map[key]\n            const now = Date.now()\n\n            if (entry) {\n                entry.value = value\n                entry.expire = now + SKIP_TIME\n            }\n            else {\n                this.map[key] = {\n                    value,\n                    expire: now + SKIP_TIME,\n                }\n            }\n        },\n        configurable: true,\n        writable: true,\n    },\n})\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/util/get-require-targets.js":"/**\n * @author Toru Nagashima\n * @copyright 2016 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\")\nconst resolve = require(\"resolve\")\nconst getTryExtensions = require(\"./get-try-extensions\")\nconst getValueIfString = require(\"./get-value-if-string\")\nconst ImportTarget = require(\"./import-target\")\nconst stripImportPathParams = require(\"./strip-import-path-params\")\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a callee.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a callee.\n */\nfunction isCallee(node) {\n    return node.parent.type === \"CallExpression\" && node.parent.callee === node\n}\n\n/**\n * Gets references of \"require\".\n *\n * @param {escope.Scope} scope - The global scope.\n * @returns {escope.Reference[]} References of \"require\".\n */\nfunction getReferencesOfRequire(scope) {\n    const variable = scope.set.get(\"require\")\n    if (!variable) {\n        // Not found.\n        return []\n    }\n    return variable.references\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Gets a list of `require()` targets.\n *\n * Core modules of Node.js (e.g. `fs`, `http`) are excluded.\n *\n * @param {RuleContext} context - The rule context.\n * @param {boolean} includeCore - The flag to include core modules.\n * @returns {ImportTarget[]} A list of found target's information.\n */\nmodule.exports = function getRequireTargets(context, includeCore) {\n    const retv = []\n    const basedir = path.dirname(path.resolve(context.getFilename()))\n    const references = getReferencesOfRequire(context.getScope())\n    const extensions = getTryExtensions(context)\n\n    for (const reference of references) {\n        const node = reference.identifier\n\n        // Skips if it's not a call of `require`.\n        if (!isCallee(node)) {\n            continue\n        }\n\n        // Gets the target module.\n        const targetNode = node.parent.arguments[0]\n        const rawName = getValueIfString(targetNode)\n        const name = rawName && stripImportPathParams(rawName)\n        if (name && (includeCore || !resolve.isCore(name))) {\n            retv.push(new ImportTarget(targetNode, name, basedir, extensions))\n        }\n    }\n\n    return retv\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/util/get-try-extensions.js":"/**\n * @author Toru Nagashima\n * @copyright 2016 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_VALUE = Object.freeze([\".js\", \".json\", \".node\"])\n\n/**\n * Gets `tryExtensions` property from a given option object.\n *\n * @param {object|undefined} option - An option object to get.\n * @returns {string[]|null} The `tryExtensions` value, or `null`.\n */\nfunction get(option) {\n    if (option && option.tryExtensions && Array.isArray(option.tryExtensions)) {\n        return option.tryExtensions.map(String)\n    }\n    return null\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Gets \"tryExtensions\" setting.\n *\n * 1. This checks `options` property, then returns it if exists.\n * 2. This checks `settings.node` property, then returns it if exists.\n * 3. This returns `[\".js\", \".json\", \".node\"]`.\n *\n * @param {RuleContext} context - The rule context.\n * @returns {string[]} A list of extensions.\n */\nmodule.exports = function getTryExtensions(context) {\n    return (\n        get(context.options && context.options[0]) ||\n        get(context.settings && context.settings.node) ||\n        DEFAULT_VALUE\n    )\n}\n\nmodule.exports.schema = {\n    type: \"array\",\n    items: {\n        type: \"string\",\n        pattern: \"^\\\\.\",\n    },\n    uniqueItems: true,\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/util/import-target.js":"/**\n * @author Toru Nagashima\n * @copyright 2016 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\")\nconst path = require(\"path\")\nconst exists = require(\"./exists\")\nconst getPackageJson = require(\"./get-package-json\")\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given path is a directory.\n *\n * @param {string} filePath - A file path to check.\n * @returns {boolean} `true` if the path is a directory.\n */\nfunction isDirectory(filePath) {\n    try {\n        return fs.statSync(filePath).isDirectory()\n    }\n    catch (_err) {\n        return false\n    }\n}\n\n/**\n * Resolve a given path as a file with given extensions.\n *\n * @param {string} filePath - A path to resolve.\n * @param {string[]} exts - Extensions that it checks whether or not the file exists.\n * @returns {string|null} The resolved path. Or `null` if failed to resolve.\n */\nfunction tryExtentions(filePath, exts) {\n    for (const ext of exts) {\n        if (exists(filePath + ext)) {\n            return filePath + ext\n        }\n    }\n\n    return null\n}\n\n/**\n * Resolve a given path as a file.\n *\n * @param {string} filePath - A path to resolve.\n * @param {string[]} exts - Extensions that it checks whether or not the file exists.\n * @returns {string|null} The resolved path. Or `null` if failed to resolve.\n */\nfunction resolveAsFile(filePath, exts) {\n    if (exists(filePath)) {\n        return filePath\n    }\n    return tryExtentions(filePath, exts)\n}\n\n/**\n * Resolve a given path as a directory.\n *\n * @param {string} filePath - A path to resolve.\n * @param {string[]} exts - Extensions that it checks whether or not the file exists.\n * @returns {string|null} The resolved path. Or `null` if failed to resolve.\n */\nfunction resolveAsDirectory(filePath, exts) {\n    if (!isDirectory(filePath)) {\n        return null\n    }\n\n    const p = getPackageJson(path.join(filePath, \"package.json\"))\n    if (p && path.dirname(p.filePath) === filePath && p.main) {\n        return resolveAsFile(path.join(filePath, p.main), exts)\n    }\n    return tryExtentions(path.join(filePath, \"index\"), exts)\n}\n\n/**\n * Resolves the file.\n *\n * @param {string} basedir - The path of base directory to resolve relative path.\n * @param {string} name - The name of an import target.\n * @param {string[]} exts - Extensions that it checks whether or not the file exists.\n * @returns {string} The resolved path.\n */\nfunction resolve(basedir, name, exts) {\n    const resolvedPath = path.resolve(basedir, name)\n    return (\n        resolveAsFile(resolvedPath, exts) ||\n        resolveAsDirectory(resolvedPath, exts) ||\n        resolvedPath\n    )\n}\n\n/**\n * Gets the module name of a given path.\n *\n * e.g. `eslint/lib/ast-utils` -> `eslint`\n *\n * @param {string} nameOrPath - A path to get.\n * @returns {string} The module name of the path.\n */\nfunction getModuleName(nameOrPath) {\n    let end = nameOrPath.indexOf(\"/\")\n    if (end !== -1 && nameOrPath[0] === \"@\") {\n        end = nameOrPath.indexOf(\"/\", 1 + end)\n    }\n\n    return end === -1 ? nameOrPath : nameOrPath.slice(0, end)\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Information of an import target.\n *\n * @constructor\n * @param {ASTNode} node - The node of a `require()` or a module declaraiton.\n * @param {string} name - The name of an import target.\n * @param {string} basedir - The path of base directory to resolve relative path.\n * @param {string[]} exts - Extensions that it checks whether or not the file exists.\n */\nmodule.exports = function ImportTarget(node, name, basedir, exts) {\n    const relative = /^\\./.test(name)\n\n    /**\n     * The node of a `require()` or a module declaraiton.\n     * @type {ASTNode}\n     */\n    this.node = node\n\n    /**\n     * The name of this import target.\n     * @type {string}\n     */\n    this.name = name\n\n    /**\n     * The full path of this import target.\n     * If the target is a module then this is `null`.\n     * @type {string|null}\n     */\n    this.filePath = relative ? resolve(basedir, name, exts) : null\n\n    /**\n     * The module name of this import target.\n     * If the target is a relative path then this is `null`.\n     * @type {string|null}\n     */\n    this.moduleName = relative ? null : getModuleName(name)\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/util/exists.js":"/**\n * @author Toru Nagashima\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\")\nconst path = require(\"path\")\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ROOT = /^(?:[/.]|\\.\\.|[A-Z]:\\\\|\\\\\\\\)(?:[/\\\\]\\.\\.)*$/\n\n/**\n * Check whether the file exists or not.\n * @param {string} filePath The file path to check.\n * @returns {boolean} `true` if the file exists.\n */\nfunction existsCaseSensitive(filePath) {\n    let dirPath = filePath\n\n    while (dirPath !== \"\" && !ROOT.test(dirPath)) {\n        const fileName = path.basename(dirPath)\n        dirPath = path.dirname(dirPath)\n\n        if (fs.readdirSync(dirPath).indexOf(fileName) === -1) {\n            return false\n        }\n    }\n\n    return true\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not the file of a given path exists.\n *\n * @param {string} filePath - A file path to check.\n * @returns {boolean} `true` if the file of a given path exists.\n */\nmodule.exports = function exists(filePath) {\n    try {\n        const relativePath = path.relative(process.cwd(), filePath)\n        return (\n            fs.statSync(relativePath).isFile() &&\n            existsCaseSensitive(relativePath)\n        )\n    }\n    catch (error) {\n        if (error.code === \"ENOENT\") {\n            return false\n        }\n        throw error\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/util/strip-import-path-params.js":"/**\n * @author Toru Nagashima\n * @copyright 2016 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = function stripImportPathParams(path) {\n    const i = path.indexOf(\"!\")\n    return i === -1 ? path : path.slice(0, i)\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/util/get-import-export-targets.js":"/**\n * @author Toru Nagashima\n * @copyright 2016 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\")\nconst resolve = require(\"resolve\")\nconst getTryExtensions = require(\"./get-try-extensions\")\nconst ImportTarget = require(\"./import-target\")\nconst stripImportPathParams = require(\"./strip-import-path-params\")\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst MODULE_TYPE = /^(?:Import|Export(?:Named|Default|All))Declaration$/\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Gets a list of `import`/`export` declaration targets.\n *\n * Core modules of Node.js (e.g. `fs`, `http`) are excluded.\n *\n * @param {RuleContext} context - The rule context.\n * @param {ASTNode} programNode - The node of Program.\n * @param {boolean} includeCore - The flag to include core modules.\n * @returns {ImportTarget[]} A list of found target's information.\n */\nmodule.exports = function getImportExportTargets(context, programNode, includeCore) {\n    const retv = []\n    const basedir = path.dirname(path.resolve(context.getFilename()))\n    const extensions = getTryExtensions(context)\n\n    for (const statement of programNode.body) {\n        // Skip if it's not a module declaration.\n        if (!MODULE_TYPE.test(statement.type)) {\n            continue\n        }\n\n        // Gets the target module.\n        const node = statement.source\n        const name = node && stripImportPathParams(node.value)\n        if (name && (includeCore || !resolve.isCore(name))) {\n            retv.push(new ImportTarget(node, name, basedir, extensions))\n        }\n    }\n\n    return retv\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/rules/no-missing-import.js":"/**\n * @author Toru Nagashima\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst checkExistence = require(\"../util/check-existence\")\nconst getAllowModules = require(\"../util/get-allow-modules\")\nconst getImportExportTargets = require(\"../util/get-import-export-targets\")\nconst getTryExtensions = require(\"../util/get-try-extensions\")\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * The definition of this rule.\n *\n * @param {RuleContext} context - The rule context to check.\n * @returns {object} The definition of this rule.\n */\nfunction create(context) {\n    const filePath = context.getFilename()\n    if (filePath === \"<input>\") {\n        return {}\n    }\n\n    return {\n        \"Program:exit\"(node) {\n            checkExistence(\n                context,\n                filePath,\n                getImportExportTargets(context, node)\n            )\n        },\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create,\n    meta: {\n        docs: {\n            description: \"disallow import declarations for files that don't exist\",\n            category: \"Possible Errors\",\n            recommended: false,\n        },\n        fixable: false,\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowModules: getAllowModules.schema,\n                    tryExtensions: getTryExtensions.schema,\n                },\n                additionalProperties: false,\n            },\n        ],\n    },\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/util/check-existence.js":"/**\n * @fileoverview Rule to check whether or not `require()` is valid.\n * @author Toru Nagashima\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\")\nconst resolve = require(\"resolve\")\nconst exists = require(\"./exists\")\nconst getAllowModules = require(\"./get-allow-modules\")\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not each requirement target exists.\n *\n * It looks up the target according to the logic of Node.js.\n * See Also: https://nodejs.org/api/modules.html\n *\n * @param {RuleContext} context - A context to report.\n * @param {string} filePath - The current file path.\n * @param {ImportTarget[]} targets - A list of target information to check.\n * @returns {void}\n */\nmodule.exports = function checkForExistence(context, filePath, targets) {\n    const allowed = getAllowModules(context)\n    const opts = {basedir: path.dirname(path.resolve(filePath))}\n\n    for (const target of targets) {\n        // Workaround for https://github.com/substack/node-resolve/issues/78\n        if (target.filePath) {\n            if (exists(target.filePath)) {\n                continue\n            }\n        }\n        else if (allowed.indexOf(target.moduleName) !== -1) {\n            continue\n        }\n        else {\n            try {\n                resolve.sync(target.name, opts)\n                continue\n            }\n            catch (_err) {\n                // ignore.\n            }\n        }\n\n        context.report({\n            node: target.node,\n            loc: target.node.loc,\n            message: \"\\\"{{name}}\\\" is not found.\",\n            data: target,\n        })\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/util/get-allow-modules.js":"/**\n * @author Toru Nagashima\n * @copyright 2016 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_VALUE = Object.freeze([])\n\n/**\n * Gets `allowModules` property from a given option object.\n *\n * @param {object|undefined} option - An option object to get.\n * @returns {string[]|null} The `allowModules` value, or `null`.\n */\nfunction get(option) {\n    if (option && option.allowModules && Array.isArray(option.allowModules)) {\n        return option.allowModules.map(String)\n    }\n    return null\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Gets \"allowModules\" setting.\n *\n * 1. This checks `options` property, then returns it if exists.\n * 2. This checks `settings.node` property, then returns it if exists.\n * 3. This returns `[]`.\n *\n * @param {RuleContext} context - The rule context.\n * @returns {string[]} A list of extensions.\n */\nmodule.exports = function getAllowModules(context) {\n    return (\n        get(context.options && context.options[0]) ||\n        get(context.settings && context.settings.node) ||\n        DEFAULT_VALUE\n    )\n}\n\nmodule.exports.schema = {\n    type: \"array\",\n    items: {\n        type: \"string\",\n        pattern: \"^(?:@[a-zA-Z0-9_\\\\-.]+/)?[a-zA-Z0-9_\\\\-.]+$\",\n    },\n    uniqueItems: true,\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/rules/no-missing-require.js":"/**\n * @author Toru Nagashima\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst checkExistence = require(\"../util/check-existence\")\nconst getAllowModules = require(\"../util/get-allow-modules\")\nconst getRequireTargets = require(\"../util/get-require-targets\")\nconst getTryExtensions = require(\"../util/get-try-extensions\")\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * The definition of this rule.\n *\n * @param {RuleContext} context - The rule context to check.\n * @returns {object} The definition of this rule.\n */\nfunction create(context) {\n    const filePath = context.getFilename()\n    if (filePath === \"<input>\") {\n        return {}\n    }\n\n    return {\n        \"Program:exit\"() {\n            checkExistence(\n                context,\n                filePath,\n                getRequireTargets(context)\n            )\n        },\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create,\n    meta: {\n        docs: {\n            description: \"disallow `require()` expressions for files that don't exist\",\n            category: \"Possible Errors\",\n            recommended: false,\n        },\n        fixable: false,\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowModules: getAllowModules.schema,\n                    tryExtensions: getTryExtensions.schema,\n                },\n                additionalProperties: false,\n            },\n        ],\n    },\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/rules/no-unpublished-bin.js":"/**\n * @author Toru Nagashima\n * @copyright 2016 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\")\nconst getConvertPath = require(\"../util/get-convert-path\")\nconst getNpmignore = require(\"../util/get-npmignore\")\nconst getPackageJson = require(\"../util/get-package-json\")\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given path is a `bin` file.\n *\n * @param {string} filePath - A file path to check.\n * @param {string|object|undefined} binField - A value of the `bin` field of `package.json`.\n * @param {string} basedir - A directory path that `package.json` exists.\n * @returns {boolean} `true` if the file is a `bin` file.\n */\nfunction isBinFile(filePath, binField, basedir) {\n    if (!binField) {\n        return false\n    }\n    if (typeof binField === \"string\") {\n        return filePath === path.resolve(basedir, binField)\n    }\n    return Object.keys(binField).some(key => filePath === path.resolve(basedir, binField[key]))\n}\n\n/**\n * The definition of this rule.\n *\n * @param {RuleContext} context - The rule context to check.\n * @returns {object} The definition of this rule.\n */\nfunction create(context) {\n    return {\n        Program(node) {\n            // Check file path.\n            let rawFilePath = context.getFilename()\n            if (rawFilePath === \"<input>\") {\n                return\n            }\n            rawFilePath = path.resolve(rawFilePath)\n\n            // Find package.json\n            const p = getPackageJson(rawFilePath)\n            if (!p) {\n                return\n            }\n\n            // Convert by convertPath option\n            const basedir = path.dirname(p.filePath)\n            const relativePath = getConvertPath(context)(\n                path.relative(basedir, rawFilePath).replace(/\\\\/g, \"/\")\n            )\n            const filePath = path.join(basedir, relativePath)\n\n            // Check this file is bin.\n            if (!isBinFile(filePath, p.bin, basedir)) {\n                return\n            }\n\n            // Check ignored or not\n            const npmignore = getNpmignore(filePath)\n            if (!npmignore.match(relativePath)) {\n                return\n            }\n\n            // Report.\n            context.report({\n                node,\n                message:\n                    \"npm ignores '{{name}}'. \" +\n                    \"Check 'files' field of 'package.json' or '.npmignore'.\",\n                data: {name: relativePath},\n            })\n        },\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create,\n    meta: {\n        docs: {\n            description: \"disallow 'bin' files that npm ignores\",\n            category: \"Possible Errors\",\n            recommended: false,\n        },\n        fixable: false,\n        schema: [\n            {\n                type: \"object\",\n                properties: { //\n                    convertPath: getConvertPath.schema,\n                },\n            },\n        ],\n    },\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/util/get-convert-path.js":"/**\n * @author Toru Nagashima\n * @copyright 2016 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Minimatch = require(\"minimatch\").Minimatch\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * @param {any} x - An any value.\n * @returns {any} Always `x`.\n */\nfunction identity(x) {\n    return x\n}\n\n/**\n * Converts old-style value to new-style value.\n *\n * @param {any} x - The value to convert.\n * @returns {({include: string[], exclude: string[], replace: string[]})[]} Normalized value.\n */\nfunction normalizeValue(x) {\n    if (Array.isArray(x)) {\n        return x\n    }\n\n    return Object.keys(x).map(pattern => ({\n        include: [pattern],\n        exclude: [],\n        replace: x[pattern],\n    }))\n}\n\n/**\n * Ensures the given value is a string array.\n *\n * @param {any} x - The value to ensure.\n * @returns {string[]} The string array.\n */\nfunction toStringArray(x) {\n    if (Array.isArray(x)) {\n        return x.map(String)\n    }\n    return []\n}\n\n/**\n * Creates the function which checks whether a file path is matched with the given pattern or not.\n *\n * @param {string[]} includePatterns - The glob patterns to include files.\n * @param {string[]} excludePatterns - The glob patterns to exclude files.\n * @returns {function} Created predicate function.\n */\nfunction createMatch(includePatterns, excludePatterns) {\n    const include = includePatterns.map(pattern => new Minimatch(pattern))\n    const exclude = excludePatterns.map(pattern => new Minimatch(pattern))\n\n    return (filePath) =>\n        include.some(m => m.match(filePath)) &&\n        !exclude.some(m => m.match(filePath))\n}\n\n/**\n * Creates a function which replaces a given path.\n *\n * @param {RegExp} fromRegexp - A `RegExp` object to replace.\n * @param {string} toStr - A new string to replace.\n * @returns {function} A function which replaces a given path.\n */\nfunction defineConvert(fromRegexp, toStr) {\n    return (filePath) =>\n        filePath.replace(fromRegexp, toStr)\n}\n\n/**\n * Combines given converters.\n * The result function converts a given path with the first matched converter.\n *\n * @param {{match: function, convert: function}} converters - A list of converters to combine.\n * @returns {function} A function which replaces a given path.\n */\nfunction combine(converters) {\n    return (filePath) => {\n        for (const converter of converters) {\n            if (converter.match(filePath)) {\n                return converter.convert(filePath)\n            }\n        }\n        return filePath\n    }\n}\n\n/**\n * Parses `convertPath` property from a given option object.\n *\n * @param {object|undefined} option - An option object to get.\n * @returns {function|null} A function which converts a path., or `null`.\n */\nfunction parse(option) {\n    if (!option ||\n        !option.convertPath ||\n        typeof option.convertPath !== \"object\"\n    ) {\n        return null\n    }\n\n    const converters = []\n    for (const pattern of normalizeValue(option.convertPath)) {\n        const include = toStringArray(pattern.include)\n        const exclude = toStringArray(pattern.exclude)\n        const fromRegexp = new RegExp(String(pattern.replace[0]))\n        const toStr = String(pattern.replace[1])\n\n        converters.push({\n            match: createMatch(include, exclude),\n            convert: defineConvert(fromRegexp, toStr),\n        })\n    }\n\n    return combine(converters)\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Gets \"convertPath\" setting.\n *\n * 1. This checks `options` property, then returns it if exists.\n * 2. This checks `settings.node` property, then returns it if exists.\n * 3. This returns a function of identity.\n *\n * @param {RuleContext} context - The rule context.\n * @returns {function} A function which converts a path.\n */\nmodule.exports = function getConvertPath(context) {\n    return (\n        parse(context.options && context.options[0]) ||\n        parse(context.settings && context.settings.node) ||\n        identity\n    )\n}\n\n/**\n * JSON Schema for `convertPath` option.\n */\nmodule.exports.schema = {\n    anyOf: [\n        {\n            type: \"object\",\n            properties: {},\n            patternProperties: {\n                \"^.+$\": {\n                    type: \"array\",\n                    items: {type: \"string\"},\n                    minItems: 2,\n                    maxItems: 2,\n                },\n            },\n            additionalProperties: false,\n        },\n        {\n            type: \"array\",\n            items: {\n                type: \"object\",\n                properties: {\n                    include: {\n                        type: \"array\",\n                        items: {type: \"string\"},\n                        minItems: 1,\n                        uniqueItems: true,\n                    },\n                    exclude: {\n                        type: \"array\",\n                        items: {type: \"string\"},\n                        uniqueItems: true,\n                    },\n                    replace: {\n                        type: \"array\",\n                        items: {type: \"string\"},\n                        minItems: 2,\n                        maxItems: 2,\n                    },\n                },\n                additionalProperties: false,\n                required: [\"include\", \"replace\"],\n            },\n            minItems: 1,\n        },\n    ],\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/util/get-npmignore.js":"/**\n * @author Toru Nagashima\n * @copyright 2016 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\")\nconst path = require(\"path\")\nconst ignore = require(\"ignore\")\nconst Cache = require(\"./cache\")\nconst exists = require(\"./exists\")\nconst getPackageJson = require(\"./get-package-json\")\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst cache = new Cache()\nconst SLASH_AT_BEGIN_END = /(?:^\\/+|\\/+$)/g\nconst PARENT_RELATIVE_PATH = /^\\.\\./\nconst NEVER_IGNORED = /^(?:readme\\.[^.]*|(?:licen[cs]e|changes|changelog|history)(?:\\.[^.]*)?)$/i\n\n/**\n * Checks whether or not a given file name is a relative path to a ancestor\n * directory.\n *\n * @param {string} filePath - A file name to check.\n * @returns {boolean} `true` if the file name is a relative path to a ancestor\n *      directory.\n */\nfunction notAncestorFiles(filePath) {\n    return PARENT_RELATIVE_PATH.test(filePath)\n}\n\n/**\n * @param {function} f - A function.\n * @param {function} g - A function.\n * @returns {function} A logical-and function of `f` and `g`.\n */\nfunction and(f, g) {\n    return (filePath) => f(filePath) && g(filePath)\n}\n\n/**\n * @param {function} f - A function.\n * @param {function} g - A function.\n * @param {function|null} h - A function.\n * @returns {function} A logical-or function of `f`, `g`, and `h`.\n */\nfunction or(f, g, h) {\n    return (filePath) => f(filePath) || g(filePath) || (h && h(filePath))\n}\n\n/**\n * @param {function} f - A function.\n * @returns {function} A logical-not function of `f`.\n */\nfunction not(f) {\n    return (filePath) => !f(filePath)\n}\n\n/**\n * Creates a function which checks whether or not a given file is ignoreable.\n *\n * @param {object} p - An object of package.json.\n * @returns {function} A function which checks whether or not a given file is ignoreable.\n */\nfunction filterNeverIgnoredFiles(p) {\n    const basedir = path.dirname(p.filePath)\n    const mainFilePath = (typeof p.main === \"string\") ? path.join(basedir, p.main) : null\n\n    return (filePath) => (\n        path.join(basedir, filePath) !== mainFilePath &&\n        filePath !== \"package.json\" &&\n        !NEVER_IGNORED.test(path.relative(basedir, filePath))\n    )\n}\n\n/**\n * Creates a function which checks whether or not a given file should be ignored.\n *\n * @param {string[]|null} files - File names of whitelist.\n * @returns {function|null} A function which checks whether or not a given file should be ignored.\n */\nfunction parseWhiteList(files) {\n    if (!files || !Array.isArray(files)) {\n        return null\n    }\n\n    const ig = ignore()\n    ig.add(\"*\")\n\n    for (const file of files) {\n        if (typeof file === \"string\") {\n            const normalized = `/${file.replace(SLASH_AT_BEGIN_END, \"\")}`\n            ig.add(`!${normalized}`)\n            ig.add(`!${normalized}/**`)\n        }\n    }\n\n    return not(ig.createFilter())\n}\n\n/**\n * Creates a function which checks whether or not a given file should be ignored.\n *\n * @param {string} basedir - The directory path \"package.json\" exists.\n * @param {boolean} filesFieldExists - `true` if `files` field of `package.json` exists.\n * @returns {function|null} A function which checks whether or not a given file should be ignored.\n */\nfunction parseNpmignore(basedir, filesFieldExists) {\n    let filePath = path.join(basedir, \".npmignore\")\n    if (!exists(filePath)) {\n        if (filesFieldExists) {\n            return null\n        }\n\n        filePath = path.join(basedir, \".gitignore\")\n        if (!exists(filePath)) {\n            return null\n        }\n    }\n\n    const ig = ignore()\n    ig.add(fs.readFileSync(filePath, \"utf8\"))\n    return not(ig.createFilter())\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Gets an object to check whther or not a given path should be ignored.\n * The object is created from:\n *\n * - `files` field of `package.json`\n * - `.npmignore`\n *\n * @param {string} startPath - A file path to lookup.\n * @returns {object}\n *      An object to check whther or not a given path should be ignored.\n *      The object has a method `match`.\n *      `match` returns `true` if a given file path should be ignored.\n */\nmodule.exports = function getNpmignore(startPath) {\n    const retv = {match: notAncestorFiles}\n\n    const p = getPackageJson(startPath)\n    if (p) {\n        const data = cache.get(p.filePath)\n        if (data) {\n            return data\n        }\n\n        const filesIgnore = parseWhiteList(p.files)\n        const npmignoreIgnore = parseNpmignore(path.dirname(p.filePath), Boolean(filesIgnore))\n\n        if (filesIgnore && npmignoreIgnore) {\n            retv.match = and(filterNeverIgnoredFiles(p), or(notAncestorFiles, filesIgnore, npmignoreIgnore))\n        }\n        else if (filesIgnore) {\n            retv.match = and(filterNeverIgnoredFiles(p), or(notAncestorFiles, filesIgnore))\n        }\n        else if (npmignoreIgnore) {\n            retv.match = and(filterNeverIgnoredFiles(p), or(notAncestorFiles, npmignoreIgnore))\n        }\n\n        cache.put(p.filePath, retv)\n    }\n\n    return retv\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/rules/no-unpublished-import.js":"/**\n * @author Toru Nagashima\n * @copyright 2016 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst checkPublish = require(\"../util/check-publish\")\nconst getAllowModules = require(\"../util/get-allow-modules\")\nconst getConvertPath = require(\"../util/get-convert-path\")\nconst getImportExportTargets = require(\"../util/get-import-export-targets\")\nconst getTryExtensions = require(\"../util/get-try-extensions\")\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * The definition of this rule.\n *\n * @param {RuleContext} context - The rule context to check.\n * @returns {object} The definition of this rule.\n */\nfunction create(context) {\n    const filePath = context.getFilename()\n    if (filePath === \"<input>\") {\n        return {}\n    }\n\n    return {\n        \"Program:exit\"(node) {\n            checkPublish(\n                context,\n                filePath,\n                getImportExportTargets(context, node)\n            )\n        },\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create,\n    meta: {\n        docs: {\n            description: \"disallow import declarations for files that npm ignores\",\n            category: \"Possible Errors\",\n            recommended: false,\n        },\n        fixable: false,\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowModules: getAllowModules.schema,\n                    convertPath: getConvertPath.schema,\n                    tryExtensions: getTryExtensions.schema,\n                },\n                additionalProperties: false,\n            },\n        ],\n    },\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/util/check-publish.js":"/**\n * @fileoverview Rule to check whether or not `require()` is valid.\n * @author Toru Nagashima\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\")\nconst assign = require(\"object-assign\")\nconst getAllowModules = require(\"./get-allow-modules\")\nconst getConvertPath = require(\"./get-convert-path\")\nconst getNpmignore = require(\"./get-npmignore\")\nconst getPackageJson = require(\"./get-package-json\")\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not each requirement target is published via package.json.\n *\n * It reads package.json and checks the target exists in `dependencies`.\n *\n * @param {RuleContext} context - A context to report.\n * @param {string} filePath - The current file path.\n * @param {ImportTarget[]} targets - A list of target information to check.\n * @returns {void}\n */\nmodule.exports = function checkForPublish(context, filePath, targets) {\n    const packageInfo = getPackageJson(filePath)\n    if (!packageInfo) {\n        return\n    }\n\n    const allowed = getAllowModules(context)\n    const convertPath = getConvertPath(context)\n    const basedir = path.dirname(packageInfo.filePath)\n    const toRelative = function(fullPath) { // eslint-disable-line func-style\n        const retv = path.relative(basedir, fullPath).replace(/\\\\/g, \"/\")\n        return convertPath(retv)\n    }\n    const npmignore = getNpmignore(filePath)\n    const dependencies = assign(\n        Object.create(null),\n        packageInfo.peerDependencies || {},\n        packageInfo.dependencies || {}\n    )\n    const devDependencies = assign(\n        Object.create(null),\n        packageInfo.devDependencies || {}\n    )\n    let i = 0\n    let target = null\n\n    if (npmignore.match(toRelative(filePath))) {\n        // This file is private, so this can import private files.\n        for (i = 0; i < targets.length; ++i) {\n            target = targets[i]\n\n            if (target.moduleName &&\n                !dependencies[target.moduleName] &&\n                !devDependencies[target.moduleName] &&\n                allowed.indexOf(target.moduleName) === -1\n            ) {\n                context.report({\n                    node: target.node,\n                    loc: target.node.loc,\n                    message: \"\\\"{{name}}\\\" is not published.\",\n                    data: {name: target.moduleName},\n                })\n            }\n        }\n    }\n    else {\n        // This file is published, so this cannot import private files.\n        for (i = 0; i < targets.length; ++i) {\n            target = targets[i]\n\n            if (target.moduleName ?\n                (!dependencies[target.moduleName] && allowed.indexOf(target.moduleName) === -1) :\n                npmignore.match(toRelative(target.filePath))\n            ) {\n                context.report({\n                    node: target.node,\n                    loc: target.node.loc,\n                    message: \"\\\"{{name}}\\\" is not published.\",\n                    data: {name: target.moduleName || target.name},\n                })\n            }\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/rules/no-unpublished-require.js":"/**\n * @author Toru Nagashima\n * @copyright 2016 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst checkPublish = require(\"../util/check-publish\")\nconst getAllowModules = require(\"../util/get-allow-modules\")\nconst getConvertPath = require(\"../util/get-convert-path\")\nconst getRequireTargets = require(\"../util/get-require-targets\")\nconst getTryExtensions = require(\"../util/get-try-extensions\")\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * The definition of this rule.\n *\n * @param {RuleContext} context - The rule context to check.\n * @returns {object} The definition of this rule.\n */\nfunction create(context) {\n    const filePath = context.getFilename()\n    if (filePath === \"<input>\") {\n        return {}\n    }\n\n    return {\n        \"Program:exit\"() {\n            checkPublish(\n                context,\n                filePath,\n                getRequireTargets(context)\n            )\n        },\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create,\n    meta: {\n        docs: {\n            description: \"disallow `require()` expressions for files that npm ignores\",\n            category: \"Possible Errors\",\n            recommended: false,\n        },\n        fixable: false,\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowModules: getAllowModules.schema,\n                    convertPath: getConvertPath.schema,\n                    tryExtensions: getTryExtensions.schema,\n                },\n                additionalProperties: false,\n            },\n        ],\n    },\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/rules/no-unsupported-features.js":"/**\n * @author Toru Nagashima\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst semver = require(\"semver\")\nconst features = require(\"../util/features\")\nconst getPackageJson = require(\"../util/get-package-json\")\nconst getValueIfString = require(\"../util/get-value-if-string\")\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst VERSIONS = [0.10, 0.12, 4, 5, 6, 7, 7.6]\nconst OPTIONS = Object.keys(features)\nconst FUNC_TYPE = /^(?:Arrow)?Function(?:Declaration|Expression)$/\nconst CLASS_TYPE = /^Class(?:Declaration|Expression)$/\nconst DESTRUCTURING_PARENT_TYPE = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression|AssignmentExpression|VariableDeclarator)$/\nconst TOPLEVEL_SCOPE_TYPE = /^(?:global|function|module)$/\nconst BINARY_NUMBER = /^0[bB]/\nconst OCTAL_NUMBER = /^0[oO]/\nconst UNICODE_ESC = /(\\\\+)u\\{[0-9a-fA-F]+?\\}/g\nconst GET_OR_SET = /^(?:g|s)et$/\nconst NEW_BUILTIN_TYPES = [\n    \"Int8Array\", \"Uint8Array\", \"Uint8ClampedArray\", \"Int16Array\", \"Uint16Array\",\n    \"Int32Array\", \"Uint32Array\", \"Float32Array\", \"Float64Array\", \"DataView\",\n    \"Map\", \"Set\", \"WeakMap\", \"WeakSet\", \"Proxy\", \"Reflect\", \"Promise\", \"Symbol\",\n]\nconst SUBCLASSING_TEST_TARGETS = [\n    \"Array\", \"RegExp\", \"Function\", \"Promise\", \"Boolean\", \"Number\", \"String\",\n    \"Map\", \"Set\",\n]\nconst PROPERTY_TEST_TARGETS = {\n    Object: [\n        \"assign\", \"is\", \"getOwnPropertySymbols\", \"setPrototypeOf\", \"values\",\n        \"entries\", \"getOwnPropertyDescriptors\",\n    ],\n    String: [\"raw\", \"fromCodePoint\"],\n    Array: [\"from\", \"of\"],\n    Number: [\n        \"isFinite\", \"isInteger\", \"isSafeInteger\", \"isNaN\", \"EPSILON\",\n        \"MIN_SAFE_INTEGER\", \"MAX_SAFE_INTEGER\",\n    ],\n    Math: [\n        \"clz32\", \"imul\", \"sign\", \"log10\", \"log2\", \"log1p\", \"expm1\", \"cosh\",\n        \"sinh\", \"tanh\", \"acosh\", \"asinh\", \"atanh\", \"trunc\", \"fround\", \"cbrt\",\n        \"hypot\",\n    ],\n    Symbol: [\n        \"hasInstance\", \"isConcatSpreadablec\", \"iterator\", \"species\", \"replace\",\n        \"search\", \"split\", \"match\", \"toPrimitive\", \"toStringTag\", \"unscopables\",\n    ],\n}\n\n/**\n * Gets major version of 'semver.Comparator'.\n *\n * @param {semver.Comparator} comparator - A comparator to get.\n * @returns {number} The major version of the comparator.\n */\nfunction parseVersion(comparator) {\n    const major = comparator.semver.major\n    const minor = comparator.semver.minor\n\n    if (major >= 1 || minor >= 10) {\n        return parseFloat(`${major}.${minor}`)\n    }\n    return 0.10\n}\n\n/**\n * Gets default version configuration of this rule.\n *\n * This finds and reads 'package.json' file, then parses 'engines.node' field.\n * If it's nothing, this returns '0.10'.\n *\n * @param {string} filename - The file name of the current linting file.\n * @returns {number} The default version configuration.\n */\nfunction getDefaultVersion(filename) {\n    const info = getPackageJson(filename)\n    const nodeVersion = info && info.engines && info.engines.node\n\n    try {\n        const range = new semver.Range(nodeVersion)\n        const comparators = Array.prototype.concat.apply([], range.set)\n        const version = comparators.reduce(\n            (minVersion, comparator) => {\n                const op = comparator.operator\n\n                if (op === \"\" || op === \">\" || op === \">=\") {\n                    return Math.min(minVersion, parseVersion(comparator))\n                }\n                return minVersion\n            },\n            Number.POSITIVE_INFINITY\n        )\n\n        if (Number.isFinite(version)) {\n            return version\n        }\n    }\n    catch (_err) {\n        // ignore\n    }\n\n    return 0.10\n}\n\n/**\n * Gets values of the `ignores` option.\n *\n * @returns {string[]} Values of the `ignores` option.\n */\nfunction getIgnoresEnum() {\n    return Object.keys(OPTIONS.reduce(\n        (retv, key) => {\n            for (const alias of features[key].alias) {\n                retv[alias] = true\n            }\n            retv[key] = true\n            return retv\n        },\n        Object.create(null)\n    ))\n}\n\n/**\n * Checks whether a given key should be ignored or not.\n *\n * @param {string} key - A key to check.\n * @param {string[]} ignores - An array of keys and aliases to be ignored.\n * @returns {boolean} `true` if the key should be ignored.\n */\nfunction isIgnored(key, ignores) {\n    return (\n        ignores.indexOf(key) !== -1 ||\n        features[key].alias.some(alias => ignores.indexOf(alias) !== -1)\n    )\n}\n\n/**\n * Parses the options.\n *\n * @param {object} options - An option object to parse.\n * @param {number} defaultVersion - The default version to use if the version option was omitted.\n * @returns {object} Parsed value.\n */\nfunction parseOptions(options, defaultVersion) {\n    let version = 0\n    let ignores = null\n\n    if (typeof options === \"number\") {\n        version = options || defaultVersion\n        ignores = []\n    }\n    else if (typeof options === \"object\") {\n        version = options.version || defaultVersion\n        ignores = options.ignores || []\n    }\n    else {\n        version = defaultVersion\n        ignores = []\n    }\n\n    return Object.freeze({\n        version: version < 1 ? version.toFixed(2) : String(version),\n        features: Object.freeze(OPTIONS.reduce(\n            (retv, key) => {\n                const feature = features[key]\n\n                if (isIgnored(key, ignores)) {\n                    retv[key] = Object.freeze({\n                        name: feature.name,\n                        singular: Boolean(feature.singular),\n                        supported: true,\n                        supportedInStrict: true,\n                    })\n                }\n                else if (typeof feature.node === \"number\") {\n                    retv[key] = Object.freeze({\n                        name: feature.name,\n                        singular: Boolean(feature.singular),\n                        supported: version >= feature.node,\n                        supportedInStrict: version >= feature.node,\n                    })\n                }\n                else {\n                    retv[key] = Object.freeze({\n                        name: feature.name,\n                        singular: Boolean(feature.singular),\n                        supported: version >= feature.node.sloppy,\n                        supportedInStrict: version >= feature.node.strict,\n                    })\n                }\n\n                return retv\n            },\n            Object.create(null)\n        )),\n    })\n}\n\n/**\n * Checks whether or not the current configure has a special lexical environment.\n * If it's modules or globalReturn then it has a special lexical environment.\n *\n * @param {RuleContext} context - A context to check.\n * @returns {boolean} `true` if the current configure is modules or globalReturn.\n */\nfunction checkSpecialLexicalEnvironment(context) {\n    const parserOptions = context.parserOptions\n    const ecmaFeatures = parserOptions.ecmaFeatures\n    return Boolean(\n        parserOptions.sourceType === \"module\" ||\n        (ecmaFeatures && ecmaFeatures.globalReturn)\n    )\n}\n\n/**\n * Gets the name of a given node.\n *\n * @param {ASTNode} node - An Identifier node to get.\n * @returns {string} The name of the node.\n */\nfunction getIdentifierName(node) {\n    return node.name\n}\n\n/**\n * Checks whether the given string has `\\u{90ABCDEF}`-like escapes.\n *\n * @param {string} raw - The string to check.\n * @returns {boolean} `true` if the string has Unicode code point escapes.\n */\nfunction hasUnicodeCodePointEscape(raw) {\n    let match = null\n\n    UNICODE_ESC.lastIndex = 0\n    while ((match = UNICODE_ESC.exec(raw)) != null) {\n        if (match[1].length % 2 === 1) {\n            return true\n        }\n    }\n\n    return false\n}\n\n/**\n * The definition of this rule.\n *\n * @param {RuleContext} context - The rule context to check.\n * @returns {object} The definition of this rule.\n */\nfunction create(context) {\n    const sourceCode = context.getSourceCode()\n    const supportInfo = parseOptions(\n        context.options[0],\n        getDefaultVersion(context.getFilename())\n    )\n    const hasSpecialLexicalEnvironment = checkSpecialLexicalEnvironment(context)\n\n    /**\n     * Gets the references of the specified global variables.\n     *\n     * @param {string[]} names - Variable names to get.\n     * @returns {void}\n     */\n    function* getReferences(names) {\n        const globalScope = context.getScope()\n\n        for (const name of names) {\n            const variable = globalScope.set.get(name)\n\n            if (variable && variable.defs.length === 0) {\n                yield* variable.references\n            }\n        }\n    }\n\n    /**\n     * Checks whether or not the current scope is strict mode.\n     *\n     * @returns {boolean}\n     *      `true` if the current scope is strict mode. Otherwise `false`.\n     */\n    function isStrict() {\n        let scope = context.getScope()\n        if (scope.type === \"global\" && hasSpecialLexicalEnvironment) {\n            scope = scope.childScopes[0]\n        }\n        return scope.isStrict\n    }\n\n    /**\n     * Checks whether the given function has trailing commas or not.\n     *\n     * @param {ASTNode} node - The function node to check.\n     * @returns {boolean} `true` if the function has trailing commas.\n     */\n    function hasTrailingCommaForFunction(node) {\n        const length = node.params.length\n\n        return (\n            length >= 1 &&\n            sourceCode.getTokenAfter(node.params[length - 1]).value === \",\"\n        )\n    }\n\n    /**\n     * Checks whether the given call expression has trailing commas or not.\n     *\n     * @param {ASTNode} node - The call expression node to check.\n     * @returns {boolean} `true` if the call expression has trailing commas.\n     */\n    function hasTrailingCommaForCall(node) {\n        return (\n            node.arguments.length >= 1 &&\n            sourceCode.getLastToken(node, 1).value === \",\"\n        )\n    }\n\n    /**\n     * Checks whether the given class extends from null or not.\n     *\n     * @param {ASTNode} node - The class node to check.\n     * @returns {boolean} `true` if the class extends from null.\n     */\n    function extendsNull(node) {\n        return (\n            node.superClass != null &&\n            node.superClass.type === \"Literal\" &&\n            node.superClass.value === null\n        )\n    }\n\n    /**\n     * Reports a given node if the specified feature is not supported.\n     *\n     * @param {ASTNode} node - A node to be reported.\n     * @param {string} key - A feature name to report.\n     * @returns {void}\n     */\n    function report(node, key) {\n        const version = supportInfo.version\n        const feature = supportInfo.features[key]\n        if (feature.supported) {\n            return\n        }\n\n        if (!feature.supportedInStrict) {\n            context.report({\n                node,\n                message: \"{{feature}} {{be}} not supported yet on Node v{{version}}.\",\n                data: {\n                    feature: feature.name,\n                    be: feature.singular ? \"is\" : \"are\",\n                    version,\n                },\n            })\n        }\n        else if (!isStrict()) {\n            context.report({\n                node,\n                message: \"{{feature}} {{be}} not supported yet on Node v{{version}}.\",\n                data: {\n                    feature: `${feature.name} in non-strict mode`,\n                    be: feature.singular ? \"is\" : \"are\",\n                    version,\n                },\n            })\n        }\n    }\n\n    return {\n        //----------------------------------------------------------------------\n        // Program\n        //----------------------------------------------------------------------\n\n        \"Program:exit\"() {\n            // Check new global variables.\n            for (const name of NEW_BUILTIN_TYPES) {\n                for (const reference of getReferences([name])) {\n                    report(reference.identifier, name)\n                }\n            }\n\n            // Check static methods.\n            for (const reference of getReferences(Object.keys(PROPERTY_TEST_TARGETS))) {\n                const node = reference.identifier\n                const parentNode = node.parent\n                if (parentNode.type !== \"MemberExpression\" ||\n                    parentNode.object !== node\n                ) {\n                    continue\n                }\n\n                const objectName = node.name\n                const properties = PROPERTY_TEST_TARGETS[objectName]\n                const propertyName = (parentNode.computed ? getValueIfString : getIdentifierName)(parentNode.property)\n                if (propertyName && properties.indexOf(propertyName) !== -1) {\n                    report(parentNode, `${objectName}.${propertyName}`)\n                }\n            }\n\n            // Check subclassing\n            for (const reference of getReferences(SUBCLASSING_TEST_TARGETS)) {\n                const node = reference.identifier\n                const parentNode = node.parent\n                if (CLASS_TYPE.test(parentNode.type) &&\n                    parentNode.superClass === node\n                ) {\n                    report(node, `extends${node.name}`)\n                }\n            }\n        },\n\n        //----------------------------------------------------------------------\n        // Functions\n        //----------------------------------------------------------------------\n\n        \"ArrowFunctionExpression\"(node) {\n            report(node, \"arrowFunctions\")\n            if (node.async) {\n                report(node, \"asyncAwait\")\n            }\n            if (hasTrailingCommaForFunction(node)) {\n                report(node, \"trailingCommasInFunctionSyntax\")\n            }\n        },\n\n        \"AssignmentPattern\"(node) {\n            if (FUNC_TYPE.test(node.parent.type)) {\n                report(node, \"defaultParameters\")\n            }\n        },\n\n        \"FunctionDeclaration\"(node) {\n            const scope = context.getScope().upper\n            if (!TOPLEVEL_SCOPE_TYPE.test(scope.type)) {\n                report(node, \"blockScopedFunctions\")\n            }\n            if (node.generator) {\n                report(node, \"generatorFunctions\")\n            }\n            if (node.async) {\n                report(node, \"asyncAwait\")\n            }\n            if (hasTrailingCommaForFunction(node)) {\n                report(node, \"trailingCommasInFunctionSyntax\")\n            }\n        },\n\n        \"FunctionExpression\"(node) {\n            if (node.generator) {\n                report(node, \"generatorFunctions\")\n            }\n            if (node.async) {\n                report(node, \"asyncAwait\")\n            }\n            if (hasTrailingCommaForFunction(node)) {\n                report(node, \"trailingCommasInFunctionSyntax\")\n            }\n        },\n\n        \"MetaProperty\"(node) {\n            const meta = node.meta.name || node.meta\n            const property = node.property.name || node.property\n            if (meta === \"new\" && property === \"target\") {\n                report(node, \"new.target\")\n            }\n        },\n\n        \"RestElement\"(node) {\n            if (FUNC_TYPE.test(node.parent.type)) {\n                report(node, \"restParameters\")\n            }\n        },\n\n        //----------------------------------------------------------------------\n        // Classes\n        //----------------------------------------------------------------------\n\n        \"ClassDeclaration\"(node) {\n            report(node, \"classes\")\n\n            if (extendsNull(node)) {\n                report(node, \"extendsNull\")\n            }\n        },\n\n        \"ClassExpression\"(node) {\n            report(node, \"classes\")\n\n            if (extendsNull(node)) {\n                report(node, \"extendsNull\")\n            }\n        },\n\n        //----------------------------------------------------------------------\n        // Statements\n        //----------------------------------------------------------------------\n\n        \"ForOfStatement\"(node) {\n            report(node, \"forOf\")\n        },\n\n        \"VariableDeclaration\"(node) {\n            if (node.kind === \"const\") {\n                report(node, \"const\")\n            }\n            else if (node.kind === \"let\") {\n                report(node, \"let\")\n            }\n        },\n\n        //----------------------------------------------------------------------\n        // Expressions\n        //----------------------------------------------------------------------\n\n        \"ArrayPattern\"(node) {\n            if (DESTRUCTURING_PARENT_TYPE.test(node.parent.type)) {\n                report(node, \"destructuring\")\n            }\n        },\n\n        \"AssignmentExpression\"(node) {\n            if (node.operator === \"**=\") {\n                report(node, \"exponentialOperators\")\n            }\n        },\n\n        \"AwaitExpression\"(node) {\n            report(node, \"asyncAwait\")\n        },\n\n        \"BinaryExpression\"(node) {\n            if (node.operator === \"**\") {\n                report(node, \"exponentialOperators\")\n            }\n        },\n\n        \"CallExpression\"(node) {\n            if (hasTrailingCommaForCall(node)) {\n                report(node, \"trailingCommasInFunctionSyntax\")\n            }\n        },\n\n        \"Identifier\"(node) {\n            const raw = sourceCode.getText(node)\n            if (hasUnicodeCodePointEscape(raw)) {\n                report(node, \"unicodeCodePointEscapes\")\n            }\n        },\n\n        \"Literal\"(node) {\n            if (typeof node.value === \"number\") {\n                if (BINARY_NUMBER.test(node.raw)) {\n                    report(node, \"binaryNumberLiterals\")\n                }\n                else if (OCTAL_NUMBER.test(node.raw)) {\n                    report(node, \"octalNumberLiterals\")\n                }\n            }\n            else if (typeof node.value === \"string\") {\n                if (hasUnicodeCodePointEscape(node.raw)) {\n                    report(node, \"unicodeCodePointEscapes\")\n                }\n            }\n            else if (node.regex) {\n                if (node.regex.flags.indexOf(\"y\") !== -1) {\n                    report(node, \"regexpY\")\n                }\n                if (node.regex.flags.indexOf(\"u\") !== -1) {\n                    report(node, \"regexpU\")\n                }\n            }\n        },\n\n        \"NewExpression\"(node) {\n            if (node.callee.type === \"Identifier\" &&\n                node.callee.name === \"RegExp\" &&\n                node.arguments.length === 2 &&\n                node.arguments[1].type === \"Literal\" &&\n                typeof node.arguments[1].value === \"string\"\n            ) {\n                if (node.arguments[1].value.indexOf(\"y\") !== -1) {\n                    report(node, \"regexpY\")\n                }\n                if (node.arguments[1].value.indexOf(\"u\") !== -1) {\n                    report(node, \"regexpU\")\n                }\n            }\n            if (hasTrailingCommaForCall(node)) {\n                report(node, \"trailingCommasInFunctionSyntax\")\n            }\n        },\n\n        \"ObjectPattern\"(node) {\n            if (DESTRUCTURING_PARENT_TYPE.test(node.parent.type)) {\n                report(node, \"destructuring\")\n            }\n        },\n\n        \"Property\"(node) {\n            if (node.parent.type === \"ObjectExpression\" &&\n                (node.computed || node.shorthand || node.method)\n            ) {\n                if (node.shorthand && GET_OR_SET.test(node.key.name)) {\n                    report(node, \"objectPropertyShorthandOfGetSet\")\n                }\n                else {\n                    report(node, \"objectLiteralExtensions\")\n                }\n            }\n        },\n\n        \"SpreadElement\"(node) {\n            report(node, \"spreadOperators\", 5)\n        },\n\n        \"TemplateLiteral\"(node) {\n            report(node, \"templateStrings\")\n        },\n\n        //----------------------------------------------------------------------\n        // Modules\n        //----------------------------------------------------------------------\n\n        \"ExportAllDeclaration\"(node) {\n            report(node, \"modules\")\n        },\n\n        \"ExportDefaultDeclaration\"(node) {\n            report(node, \"modules\")\n        },\n\n        \"ExportNamedDeclaration\"(node) {\n            report(node, \"modules\")\n        },\n\n        \"ImportDeclaration\"(node) {\n            report(node, \"modules\")\n        },\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create,\n    meta: {\n        docs: {\n            description: \"disallow unsupported ECMAScript features on the specified version\",\n            category: \"Possible Errors\",\n            recommended: false,\n        },\n        fixable: false,\n        schema: [\n            {\n                oneOf: [\n                    {enum: VERSIONS},\n                    {\n                        type: \"object\",\n                        properties: {\n                            version: {enum: VERSIONS},\n                            ignores: {\n                                type: \"array\",\n                                items: {enum: getIgnoresEnum()},\n                                uniqueItems: true,\n                            },\n                        },\n                        additionalProperties: false,\n                    },\n                ],\n            },\n        ],\n    },\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/util/features.js":"/**\n * @author Toru Nagashima\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    //--------------------------------------------------------------------------\n    // Syntax\n    //--------------------------------------------------------------------------\n\n    \"defaultParameters\": {\n        alias: [\"syntax\"],\n        name: \"Default Parameters\",\n        node: 6,\n    },\n    \"restParameters\": {\n        alias: [\"syntax\"],\n        name: \"Rest Parameters\",\n        node: 6,\n    },\n    \"spreadOperators\": {\n        alias: [\"syntax\"],\n        name: \"Spread Operators\",\n        node: 5,\n    },\n    \"objectLiteralExtensions\": {\n        alias: [\"syntax\"],\n        name: \"Object Literal Extensions\",\n        node: 4,\n    },\n    \"objectPropertyShorthandOfGetSet\": {\n        alias: [\"syntax\", \"objectLiteralExtensions\"],\n        name: \"Property Shorthand of 'get' and 'set'\",\n        node: 6,\n    },\n    \"forOf\": {\n        alias: [\"syntax\"],\n        name: \"'for..of' Loops\",\n        node: 0.12,\n    },\n    \"binaryNumberLiterals\": {\n        alias: [\"syntax\"],\n        name: \"Binary Number Literals\",\n        node: 4,\n    },\n    \"octalNumberLiterals\": {\n        alias: [\"syntax\"],\n        name: \"Octal Number Literals\",\n        node: 4,\n    },\n    \"templateStrings\": {\n        alias: [\"syntax\"],\n        name: \"Template Strings\",\n        node: 4,\n    },\n    \"regexpY\": {\n        alias: [\"syntax\"],\n        name: \"RegExp 'y' Flags\",\n        node: 6,\n    },\n    \"regexpU\": {\n        alias: [\"syntax\"],\n        name: \"RegExp 'u' Flags\",\n        node: 6,\n    },\n    \"destructuring\": {\n        alias: [\"syntax\"],\n        name: \"Destructuring\",\n        node: 6,\n    },\n    \"unicodeCodePointEscapes\": {\n        alias: [\"syntax\"],\n        name: \"Unicode Code Point Escapes\",\n        node: 4,\n    },\n    \"new.target\": {\n        alias: [\"syntax\"],\n        name: \"'new.target'\",\n        node: 5,\n    },\n    \"const\": {\n        alias: [\"syntax\"],\n        name: \"'const' Declarations\",\n        node: {\n            sloppy: 6,\n            strict: 4,\n        },\n    },\n    \"let\": {\n        alias: [\"syntax\"],\n        name: \"'let' Declarations\",\n        node: {\n            sloppy: 6,\n            strict: 4,\n        },\n    },\n    \"blockScopedFunctions\": {\n        alias: [\"syntax\"],\n        name: \"Block-Scoped Functions\",\n        node: {\n            sloppy: 6,\n            strict: 4,\n        },\n    },\n    \"arrowFunctions\": {\n        alias: [\"syntax\"],\n        name: \"Arrow Functions\",\n        node: 4,\n    },\n    \"generatorFunctions\": {\n        alias: [\"syntax\"],\n        name: \"Generator Functions\",\n        node: 4,\n    },\n    \"classes\": {\n        alias: [\"syntax\"],\n        name: \"Classes\",\n        node: {\n            sloppy: 6,\n            strict: 4,\n        },\n    },\n    \"modules\": {\n        alias: [\"syntax\"],\n        name: \"Import and Export Declarations\",\n        node: NaN,\n    },\n    \"exponentialOperators\": {\n        alias: [\"syntax\"],\n        name: \"Exponential Operators (**)\",\n        node: 7,\n    },\n    \"asyncAwait\": {\n        alias: [\"syntax\"],\n        name: \"Async Functions\",\n        node: 7.6,\n    },\n    \"trailingCommasInFunctionSyntax\": {\n        alias: [\"syntax\"],\n        name: \"Trailing Commas in Function Syntax\",\n        node: NaN,\n    },\n\n    //--------------------------------------------------------------------------\n    // Runtime\n    //--------------------------------------------------------------------------\n\n    \"Int8Array\": {\n        alias: [\"runtime\", \"globalObjects\", \"typedArrays\"],\n        name: \"'Int8Array'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Uint8Array\": {\n        alias: [\"runtime\", \"globalObjects\", \"typedArrays\"],\n        name: \"'Uint8Array'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Uint8ClampedArray\": {\n        alias: [\"runtime\", \"globalObjects\", \"typedArrays\"],\n        name: \"'Uint8ClampedArray'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Int16Array\": {\n        alias: [\"runtime\", \"globalObjects\", \"typedArrays\"],\n        name: \"'Int16Array'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Uint16Array\": {\n        alias: [\"runtime\", \"globalObjects\", \"typedArrays\"],\n        name: \"'Uint16Array'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Int32Array\": {\n        alias: [\"runtime\", \"globalObjects\", \"typedArrays\"],\n        name: \"'Int32Array'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Uint32Array\": {\n        alias: [\"runtime\", \"globalObjects\", \"typedArrays\"],\n        name: \"'Uint32Array'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Float32Array\": {\n        alias: [\"runtime\", \"globalObjects\", \"typedArrays\"],\n        name: \"'Float32Array'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Float64Array\": {\n        alias: [\"runtime\", \"globalObjects\", \"typedArrays\"],\n        name: \"'Float64Array'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"DataView\": {\n        alias: [\"runtime\", \"globalObjects\", \"typedArrays\"],\n        name: \"'DataView'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Map\": {\n        alias: [\"runtime\", \"globalObjects\"],\n        name: \"'Map'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Set\": {\n        alias: [\"runtime\", \"globalObjects\"],\n        name: \"'Set'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"WeakMap\": {\n        alias: [\"runtime\", \"globalObjects\"],\n        name: \"'WeakMap'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"WeakSet\": {\n        alias: [\"runtime\", \"globalObjects\"],\n        name: \"'WeakSet'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Proxy\": {\n        alias: [\"runtime\", \"globalObjects\"],\n        name: \"'Proxy'\",\n        singular: true,\n        node: 6,\n    },\n    \"Reflect\": {\n        alias: [\"runtime\", \"globalObjects\"],\n        name: \"'Reflect'\",\n        singular: true,\n        node: 6,\n    },\n    \"Promise\": {\n        alias: [\"runtime\", \"globalObjects\"],\n        name: \"'Promise'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Symbol\": {\n        alias: [\"runtime\", \"globalObjects\"],\n        name: \"'Symbol'\",\n        singular: true,\n        node: 0.12,\n    },\n\n    \"Object.assign\": {\n        alias: [\"runtime\", \"staticMethods\", \"Object.*\"],\n        name: \"'Object.assign'\",\n        singular: true,\n        node: 4,\n    },\n    \"Object.is\": {\n        alias: [\"runtime\", \"staticMethods\", \"Object.*\"],\n        name: \"'Object.is'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Object.getOwnPropertySymbols\": {\n        alias: [\"runtime\", \"staticMethods\", \"Object.*\"],\n        name: \"'Object.getOwnPropertySymbols'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Object.setPrototypeOf\": {\n        alias: [\"runtime\", \"staticMethods\", \"Object.*\"],\n        name: \"'Object.setPrototypeOf'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Object.values\": {\n        alias: [\"runtime\", \"staticMethods\", \"Object.*\"],\n        name: \"'Object.values'\",\n        singular: true,\n        node: 7,\n    },\n    \"Object.entries\": {\n        alias: [\"runtime\", \"staticMethods\", \"Object.*\"],\n        name: \"'Object.entries'\",\n        singular: true,\n        node: 7,\n    },\n    \"Object.getOwnPropertyDescriptors\": {\n        alias: [\"runtime\", \"staticMethods\", \"Object.*\"],\n        name: \"'Object.getOwnPropertyDescriptors'\",\n        singular: true,\n        node: 7,\n    },\n\n    \"String.raw\": {\n        alias: [\"runtime\", \"staticMethods\", \"String.*\"],\n        name: \"'String.raw'\",\n        singular: true,\n        node: 4,\n    },\n    \"String.fromCodePoint\": {\n        alias: [\"runtime\", \"staticMethods\", \"String.*\"],\n        name: \"'String.fromCodePoint'\",\n        singular: true,\n        node: 4,\n    },\n\n    \"Array.from\": {\n        alias: [\"runtime\", \"staticMethods\", \"Array.*\"],\n        name: \"'Array.from'\",\n        singular: true,\n        node: 4,\n    },\n    \"Array.of\": {\n        alias: [\"runtime\", \"staticMethods\", \"Array.*\"],\n        name: \"'Array.of'\",\n        singular: true,\n        node: 4,\n    },\n\n    \"Number.isFinite\": {\n        alias: [\"runtime\", \"staticMethods\", \"Number.*\"],\n        name: \"'Number.isFinite'\",\n        singular: true,\n        node: 0.10,\n    },\n    \"Number.isInteger\": {\n        alias: [\"runtime\", \"staticMethods\", \"Number.*\"],\n        name: \"'Number.isInteger'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Number.isSafeInteger\": {\n        alias: [\"runtime\", \"staticMethods\", \"Number.*\"],\n        name: \"'Number.isSafeInteger'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Number.isNaN\": {\n        alias: [\"runtime\", \"staticMethods\", \"Number.*\"],\n        name: \"'Number.isNaN'\",\n        singular: true,\n        node: 0.10,\n    },\n    \"Number.EPSILON\": {\n        alias: [\"runtime\", \"staticMethods\", \"Number.*\"],\n        name: \"'Number.EPSILON'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Number.MIN_SAFE_INTEGER\": {\n        alias: [\"runtime\", \"staticMethods\", \"Number.*\"],\n        name: \"'Number.MIN_SAFE_INTEGER'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Number.MAX_SAFE_INTEGER\": {\n        alias: [\"runtime\", \"staticMethods\", \"Number.*\"],\n        name: \"'Number.MAX_SAFE_INTEGER'\",\n        singular: true,\n        node: 0.12,\n    },\n\n    \"Math.clz32\": {\n        alias: [\"runtime\", \"staticMethods\", \"Math.*\"],\n        name: \"'Math.clz32'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Math.imul\": {\n        alias: [\"runtime\", \"staticMethods\", \"Math.*\"],\n        name: \"'Math.imul'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Math.sign\": {\n        alias: [\"runtime\", \"staticMethods\", \"Math.*\"],\n        name: \"'Math.sign'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Math.log10\": {\n        alias: [\"runtime\", \"staticMethods\", \"Math.*\"],\n        name: \"'Math.log10'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Math.log2\": {\n        alias: [\"runtime\", \"staticMethods\", \"Math.*\"],\n        name: \"'Math.log2'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Math.log1p\": {\n        alias: [\"runtime\", \"staticMethods\", \"Math.*\"],\n        name: \"'Math.log1p'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Math.expm1\": {\n        alias: [\"runtime\", \"staticMethods\", \"Math.*\"],\n        name: \"'Math.expm1'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Math.cosh\": {\n        alias: [\"runtime\", \"staticMethods\", \"Math.*\"],\n        name: \"'Math.cosh'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Math.sinh\": {\n        alias: [\"runtime\", \"staticMethods\", \"Math.*\"],\n        name: \"'Math.sinh'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Math.tanh\": {\n        alias: [\"runtime\", \"staticMethods\", \"Math.*\"],\n        name: \"'Math.tanh'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Math.acosh\": {\n        alias: [\"runtime\", \"staticMethods\", \"Math.*\"],\n        name: \"'Math.acosh'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Math.asinh\": {\n        alias: [\"runtime\", \"staticMethods\", \"Math.*\"],\n        name: \"'Math.asinh'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Math.atanh\": {\n        alias: [\"runtime\", \"staticMethods\", \"Math.*\"],\n        name: \"'Math.atanh'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Math.trunc\": {\n        alias: [\"runtime\", \"staticMethods\", \"Math.*\"],\n        name: \"'Math.trunc'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Math.fround\": {\n        alias: [\"runtime\", \"staticMethods\", \"Math.*\"],\n        name: \"'Math.fround'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Math.cbrt\": {\n        alias: [\"runtime\", \"staticMethods\", \"Math.*\"],\n        name: \"'Math.cbrt'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Math.hypot\": {\n        alias: [\"runtime\", \"staticMethods\", \"Math.*\"],\n        name: \"'Math.hypot'\",\n        singular: true,\n        node: 0.12,\n    },\n\n    \"Symbol.hasInstance\": {\n        alias: [\"runtime\", \"staticMethods\", \"Symbol.*\"],\n        name: \"'Symbol.hasInstance'\",\n        singular: true,\n        node: NaN,\n    },\n    \"Symbol.isConcatSpreadablec\": {\n        alias: [\"runtime\", \"staticMethods\", \"Symbol.*\"],\n        name: \"'Symbol.isConcatSpreadablec'\",\n        singular: true,\n        node: 6,\n    },\n    \"Symbol.iterator\": {\n        alias: [\"runtime\", \"staticMethods\", \"Symbol.*\"],\n        name: \"'Symbol.iterator'\",\n        singular: true,\n        node: 0.12,\n    },\n    \"Symbol.species\": {\n        alias: [\"runtime\", \"staticMethods\", \"Symbol.*\"],\n        name: \"'Symbol.species'\",\n        singular: true,\n        node: NaN,\n    },\n    \"Symbol.replace\": {\n        alias: [\"runtime\", \"staticMethods\", \"Symbol.*\"],\n        name: \"'Symbol.replace'\",\n        singular: true,\n        node: 6,\n    },\n    \"Symbol.search\": {\n        alias: [\"runtime\", \"staticMethods\", \"Symbol.*\"],\n        name: \"'Symbol.search'\",\n        singular: true,\n        node: 6,\n    },\n    \"Symbol.split\": {\n        alias: [\"runtime\", \"staticMethods\", \"Symbol.*\"],\n        name: \"'Symbol.split'\",\n        singular: true,\n        node: 6,\n    },\n    \"Symbol.match\": {\n        alias: [\"runtime\", \"staticMethods\", \"Symbol.*\"],\n        name: \"'Symbol.match'\",\n        singular: true,\n        node: 6,\n    },\n    \"Symbol.toPrimitive\": {\n        alias: [\"runtime\", \"staticMethods\", \"Symbol.*\"],\n        name: \"'Symbol.toPrimitive'\",\n        singular: true,\n        node: 6,\n    },\n    \"Symbol.toStringTag\": {\n        alias: [\"runtime\", \"staticMethods\", \"Symbol.*\"],\n        name: \"'Symbol.toStringTag'\",\n        singular: true,\n        node: 6,\n    },\n    \"Symbol.unscopables\": {\n        alias: [\"runtime\", \"staticMethods\", \"Symbol.*\"],\n        name: \"'Symbol.unscopables'\",\n        singular: true,\n        node: 4,\n    },\n\n    \"extendsArray\": {\n        alias: [\"runtime\", \"extends\"],\n        name: \"Subclassing of 'Array'\",\n        singular: true,\n        node: 6,\n    },\n    \"extendsRegExp\": {\n        alias: [\"runtime\", \"extends\"],\n        name: \"Subclassing of 'RegExp'\",\n        singular: true,\n        node: 5,\n    },\n    \"extendsFunction\": {\n        alias: [\"runtime\", \"extends\"],\n        name: \"Subclassing of 'Function'\",\n        singular: true,\n        node: 6,\n    },\n    \"extendsPromise\": {\n        alias: [\"runtime\", \"extends\"],\n        name: \"Subclassing of 'Promise'\",\n        singular: true,\n        node: 5,\n    },\n    \"extendsBoolean\": {\n        alias: [\"runtime\", \"extends\"],\n        name: \"Subclassing of 'Boolean'\",\n        singular: true,\n        node: 4,\n    },\n    \"extendsNumber\": {\n        alias: [\"runtime\", \"extends\"],\n        name: \"Subclassing of 'Number'\",\n        singular: true,\n        node: 4,\n    },\n    \"extendsString\": {\n        alias: [\"runtime\", \"extends\"],\n        name: \"Subclassing of 'String'\",\n        singular: true,\n        node: 4,\n    },\n    \"extendsMap\": {\n        alias: [\"runtime\", \"extends\"],\n        name: \"Subclassing of 'Map'\",\n        singular: true,\n        node: 4,\n    },\n    \"extendsSet\": {\n        alias: [\"runtime\", \"extends\"],\n        name: \"Subclassing of 'Set'\",\n        singular: true,\n        node: 4,\n    },\n    \"extendsNull\": {\n        alias: [\"runtime\", \"extends\"],\n        name: \"'extends null'\",\n        singular: true,\n        node: NaN,\n    },\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/rules/process-exit-as-throw.js":"/**\n * @author Toru Nagashima\n * @copyright 2016 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathAnalyzer = safeRequire(\"eslint/lib/code-path-analysis/code-path-analyzer\")\nconst CodePath = safeRequire(\"eslint/lib/code-path-analysis/code-path\")\nconst CodePathSegment = safeRequire(\"eslint/lib/code-path-analysis/code-path-segment\")\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst originalLeaveNode = CodePathAnalyzer && CodePathAnalyzer.prototype.leaveNode\n\n/**\n * Imports a specific module.\n *\n * @param {string} moduleName - A module name to import.\n * @returns {object|null} The imported object, or null.\n */\nfunction safeRequire(moduleName) {\n    try {\n        return require(moduleName)\n    }\n    catch (_err) {\n        return null\n    }\n}\n\n/* istanbul ignore next */\n/**\n * Copied from https://github.com/eslint/eslint/blob/16fad5880bb70e9dddbeab8ed0f425ae51f5841f/lib/code-path-analysis/code-path-analyzer.js#L137\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction forwardCurrentToHead(analyzer, node) {\n    const codePath = analyzer.codePath\n    const state = CodePath.getState(codePath)\n    const currentSegments = state.currentSegments\n    const headSegments = state.headSegments\n    const end = Math.max(currentSegments.length, headSegments.length)\n    let i = 0\n    let currentSegment = null\n    let headSegment = null\n\n    // Fires leaving events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i]\n        headSegment = headSegments[i]\n\n        if (currentSegment !== headSegment && currentSegment) {\n            if (currentSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentEnd\",\n                    currentSegment,\n                    node)\n            }\n        }\n    }\n\n    // Update state.\n    state.currentSegments = headSegments\n\n    // Fires entering events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i]\n        headSegment = headSegments[i]\n\n        if (currentSegment !== headSegment && headSegment) {\n            CodePathSegment.markUsed(headSegment)\n            if (headSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentStart\",\n                    headSegment,\n                    node)\n            }\n        }\n    }\n}\n\n/**\n * Checks whether a given node is `process.exit()` or not.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is `process.exit()`.\n */\nfunction isProcessExit(node) {\n    return (\n        node.type === \"CallExpression\" &&\n        node.callee.type === \"MemberExpression\" &&\n        node.callee.computed === false &&\n        node.callee.object.type === \"Identifier\" &&\n        node.callee.object.name === \"process\" &&\n        node.callee.property.type === \"Identifier\" &&\n        node.callee.property.name === \"exit\"\n    )\n}\n\n/**\n * The function to override `CodePathAnalyzer.prototype.leaveNode` in order to\n * address `process.exit()` as throw.\n *\n * @this CodePathAnalyzer\n * @param {ASTNode} node - A node to be left.\n * @returns {void}\n */\nfunction overrideLeaveNode(node) {\n    if (isProcessExit(node)) {\n        this.currentNode = node\n\n        forwardCurrentToHead(this, node)\n        CodePath.getState(this.codePath).makeThrow()\n\n        this.original.leaveNode(node)\n        this.currentNode = null\n    }\n    else {\n        originalLeaveNode.call(this, node)\n    }\n}\n\nconst visitor = CodePathAnalyzer == null ? {} : {\n    \"Program\": function installProcessExitAsThrow() {\n        CodePathAnalyzer.prototype.leaveNode = overrideLeaveNode\n    },\n    \"Program:exit\": function restoreProcessExitAsThrow() {\n        CodePathAnalyzer.prototype.leaveNode = originalLeaveNode\n    },\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"make the same code path as `throw` at `process.exit()`\",\n            category: \"Possible Errors\",\n            recommended: false,\n        },\n        fixable: false,\n        schema: [],\n        supported: CodePathAnalyzer != null,\n    },\n    create() {\n        return visitor\n    },\n}\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-node/node_modules/eslint-plugin-node/lib/rules/shebang.js":"/**\n * @author Toru Nagashima\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\"\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\")\nconst getConvertPath = require(\"../util/get-convert-path\")\nconst getPackageJson = require(\"../util/get-package-json\")\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst NODE_SHEBANG = \"#!/usr/bin/env node\\n\"\nconst SHEBANG_PATTERN = /^(#!.+?)?(\\r)?\\n/\nconst NODE_SHEBANG_PATTERN = /#!\\/usr\\/bin\\/env node(?: [^\\r\\n]+?)?\\n/\n\n/**\n * Checks whether or not a given path is a `bin` file.\n *\n * @param {string} filePath - A file path to check.\n * @param {string|object|undefined} binField - A value of the `bin` field of `package.json`.\n * @param {string} basedir - A directory path that `package.json` exists.\n * @returns {boolean} `true` if the file is a `bin` file.\n */\nfunction isBinFile(filePath, binField, basedir) {\n    if (!binField) {\n        return false\n    }\n    if (typeof binField === \"string\") {\n        return filePath === path.resolve(basedir, binField)\n    }\n    return Object.keys(binField).some(key => filePath === path.resolve(basedir, binField[key]))\n}\n\n/**\n * Gets the shebang line (includes a line ending) from a given code.\n *\n * @param {SourceCode} sourceCode - A source code object to check.\n * @returns {{length: number, bom: boolean, shebang: string, cr: boolean}}\n *      shebang's information.\n *      `retv.shebang` is an empty string if shebang doesn't exist.\n */\nfunction getShebangInfo(sourceCode) {\n    const m = SHEBANG_PATTERN.exec(sourceCode.text)\n\n    return {\n        bom: sourceCode.hasBOM,\n        cr: Boolean(m && m[2]),\n        length: (m && m[0].length) || 0,\n        shebang: (m && m[1] && (`${m[1]}\\n`)) || \"\",\n    }\n}\n\n/**\n * The definition of this rule.\n *\n * @param {RuleContext} context - The rule context to check.\n * @returns {object} The definition of this rule.\n */\nfunction create(context) {\n    const sourceCode = context.getSourceCode()\n    let filePath = context.getFilename()\n    if (filePath === \"<input>\") {\n        return {}\n    }\n    filePath = path.resolve(filePath)\n\n    const p = getPackageJson(filePath)\n    if (!p) {\n        return {}\n    }\n\n    const basedir = path.dirname(p.filePath)\n    filePath = path.join(\n        basedir,\n        getConvertPath(context)(path.relative(basedir, filePath).replace(/\\\\/g, \"/\"))\n    )\n\n    const needsShebang = isBinFile(filePath, p.bin, basedir)\n    const info = getShebangInfo(sourceCode)\n\n    return {\n        Program(node) {\n            if (needsShebang ? NODE_SHEBANG_PATTERN.test(info.shebang) : !info.shebang) {\n                // Good the shebang target.\n                // Checks BOM and \\r.\n                if (needsShebang && info.bom) {\n                    context.report({\n                        node,\n                        message: \"This file must not have Unicode BOM.\",\n                        fix(fixer) {\n                            return fixer.removeRange([-1, 0])\n                        },\n                    })\n                }\n                if (needsShebang && info.cr) {\n                    context.report({\n                        node,\n                        message: \"This file must have Unix linebreaks (LF).\",\n                        fix(fixer) {\n                            const index = sourceCode.text.indexOf(\"\\r\")\n                            return fixer.removeRange([index, index + 1])\n                        },\n                    })\n                }\n            }\n            else if (needsShebang) {\n                // Shebang is lacking.\n                context.report({\n                    node,\n                    message: \"This file needs shebang \\\"#!/usr/bin/env node\\\".\",\n                    fix(fixer) {\n                        return fixer.replaceTextRange([-1, info.length], NODE_SHEBANG)\n                    },\n                })\n            }\n            else {\n                // Shebang is extra.\n                context.report({\n                    node,\n                    message: \"This file needs no shebang.\",\n                    fix(fixer) {\n                        return fixer.removeRange([0, info.length])\n                    },\n                })\n            }\n        },\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    create,\n    meta: {\n        docs: {\n            description: \"enforce the correct usage of shebang\",\n            category: \"Possible Errors\",\n            recommended: false,\n        },\n        fixable: \"code\",\n        schema: [\n            {\n                type: \"object\",\n                properties: { //\n                    convertPath: getConvertPath.schema,\n                },\n                additionalProperties: false,\n            },\n        ],\n    },\n}\n"}